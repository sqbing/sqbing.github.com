{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/cactus/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/cactus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/css/fontawesome-all.min.css","path":"lib/font-awesome/css/fontawesome-all.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff","path":"lib/font-awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.eot","path":"lib/font-awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff","path":"lib/font-awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff","path":"lib/font-awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.eot","path":"lib/font-awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.svg","path":"lib/font-awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.eot","path":"lib/font-awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","path":"lib/meslo-LG/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","path":"lib/meslo-LG/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","path":"lib/meslo-LG/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.svg","path":"lib/font-awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","path":"lib/meslo-LG/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","path":"lib/meslo-LG/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","path":"lib/meslo-LG/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","path":"lib/meslo-LG/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","path":"lib/meslo-LG/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","path":"lib/meslo-LG/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.svg","path":"lib/font-awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/cactus/.gitignore","hash":"8d1ea5895c15244978ee32f4ef280124512d995a","modified":1520403073316},{"_id":"themes/cactus/.jshintrc","hash":"d6ee46102ed2ff00acb555557f47241b701e99a4","modified":1520403073317},{"_id":"themes/cactus/.stylintrc","hash":"8bbbee5eae70fbe7dd53c9ce43d244b47d58385b","modified":1520403073318},{"_id":"themes/cactus/LICENSE","hash":"06806c75801c9ae870a1b47d588ef8e00d3c7c94","modified":1520403073319},{"_id":"themes/cactus/README.md","hash":"eee605af535377f2f4d452fa05cdd6d35be6a05e","modified":1520403073320},{"_id":"themes/cactus/_config.yml","hash":"bdec8ababab91ecf6d448a7ea4a3b13dbdecc20e","modified":1532073117676},{"_id":"themes/cactus/gulpfile.js","hash":"4c57fee21d482c2061abb066595b272c27bb0f4a","modified":1520403073322},{"_id":"themes/cactus/package.json","hash":"52400b7503efa96822401ce51bad57dc5420974b","modified":1520403073348},{"_id":"source/_posts/2013-03-26-new-post.md","hash":"9840079111805446627218fe65dcabe7c9cb6f73","modified":1520403073295},{"_id":"source/_posts/2013-04-01-unreliable-backtrace.md","hash":"4d3cdbc5790260baec6d32b4793e2c8e94e1b809","modified":1520403073296},{"_id":"source/_posts/2013-04-03-deps.md","hash":"e54e8e70a72c724146515beaeebf2bacde7825ff","modified":1520403073297},{"_id":"source/_posts/2013-04-12-cpp_standard_library_string_find_and_npos_usage.md","hash":"31f9a7e7c16207bfec07363756b3b1baa8df6fca","modified":1520403073298},{"_id":"source/_posts/2013-07-20-delpoy-bottle-to-gae.md","hash":"7264f940fabe8c01ea279af3ca66f00a76b4d886","modified":1520403073299},{"_id":"source/_posts/2013-07-23-nginx-rtmp-module-summary.md","hash":"95f32d11822fd76b3fb056051b63874589773940","modified":1520403073301},{"_id":"source/_posts/2013-07-27-boost-property_tree-threadsafe.md","hash":"b923fad407c4ea987cbbb6ec3f5e0ec0e3954cb0","modified":1520403073302},{"_id":"source/_posts/2013-09-26-something-about-nginx-and-hls.md","hash":"42a46055ac17bbc2c4ac0159fb8e084aae4e33df","modified":1520403073303},{"_id":"source/_posts/2013-09-30-fix-ffmpeg-librtmp-not-found.md","hash":"1c898197d5988651105a2f26370ddaeaef191d6c","modified":1520403073304},{"_id":"source/_posts/2013-09-29-fix-nexus-7-2013-otg-storage.md","hash":"751857d1439df94a63f414ecd3b701381cafe857","modified":1520403073303},{"_id":"source/_posts/2013-10-10-ffmpeg-mosaic.md","hash":"dfc8af02d5eed3f10405ec4de6aad157b1423b3d","modified":1520403073305},{"_id":"source/_posts/2013-10-11-from-wordpress-to-github.md","hash":"8451c4fcd8032b7045d817079aa2005738df5d01","modified":1520403073307},{"_id":"source/_posts/2013-10-10-write-blog-with-prose.md","hash":"f34510d6538e03fe29177b1c41bd5e1fab435e18","modified":1520403073306},{"_id":"source/_posts/2013-10-14-lua-note-1.md","hash":"6ec44a5ee0df12125fa3c9487c370782985d299f","modified":1520403073308},{"_id":"source/_posts/2013-11-27-riders_resume.md","hash":"3443e0be3b973ad64f668d1058b4384d1de0162f","modified":1520403073309},{"_id":"source/_posts/2013-11-27-xauth_with_node.md","hash":"18a81cf23a1a73662591fc05053b6dea5494f738","modified":1520403073310},{"_id":"source/_posts/2015-04-01-android-pre-compiler-error.md","hash":"1598f7176db355dc0285c963d72cb2ea417529f0","modified":1520403073313},{"_id":"source/_posts/2014-06-24-MP4-to-HLS-based-on-nginx-http-mp4-module.md","hash":"ab28bfd564a1afffaa7f9ad2687f539ec412acdd","modified":1520403073312},{"_id":"source/_posts/2014-06-24-HTTP-Live-Streaming-notes.md","hash":"4563967a9d0251d11cf7336cbaaf948c9292c1b6","modified":1520403073311},{"_id":"source/_posts/2015-12-22-cpp-cast.md","hash":"6a11d5c27d7d456707e24bba282726ced1045775","modified":1520403073313},{"_id":"source/_posts/2018-03-07-PowerShell-font.md","hash":"c1331edb80fb107a792d46e2edbbf808de6d4beb","modified":1526620069520},{"_id":"source/_posts/2018-03-07-migrate-to-hexo.md","hash":"84efdb8d1dc7f810796816a32a53978964b44ae2","modified":1532073281275},{"_id":"themes/cactus/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1520403073323},{"_id":"themes/cactus/languages/en.yml","hash":"0c20c8db077c7197db3f4254ef2b2b2caa56a1b1","modified":1520403073324},{"_id":"themes/cactus/languages/nl.yml","hash":"4c36921322e782775ccff9aec78d4261153cf5e5","modified":1520403073326},{"_id":"themes/cactus/languages/fr.yml","hash":"7e8269d0c2ca031b7c037168c9c3d45ec83b1d0e","modified":1520403073325},{"_id":"themes/cactus/languages/zh-CN.yml","hash":"7b7bf5d49b3f5b1bde265be1a944d6a16351a84f","modified":1520403073327},{"_id":"themes/cactus/layout/archive.ejs","hash":"46fcf152b97cb12ea851132b96a775a3460465d0","modified":1520403073343},{"_id":"themes/cactus/layout/layout.ejs","hash":"716de3955cd48fd6e6cc520538be633d9e0d92ba","modified":1520403073345},{"_id":"themes/cactus/layout/index.ejs","hash":"95b445da1d491aef2763c1e5f686010093337081","modified":1520403073344},{"_id":"themes/cactus/layout/page.ejs","hash":"55c58a1924f632c5fa22d5a17465d6fc3bb16127","modified":1520403073346},{"_id":"themes/cactus/layout/post.ejs","hash":"07245374d3b74bfd5fd7b91228e55aa19b14e017","modified":1520403073347},{"_id":"themes/cactus/scripts/merge-configs.js","hash":"98b79403945fa7f8dc177e6da283681677d02567","modified":1520403073349},{"_id":"themes/cactus/scripts/meta.js","hash":"6b05bc75ab2478a1f01deab46919164895eb1f6d","modified":1520403073350},{"_id":"themes/cactus/scripts/thumbnail.js","hash":"3d841aa267026703a5cc29f4ffbb613f0a2bbd45","modified":1520403073351},{"_id":"themes/cactus/layout/_partial/comments.ejs","hash":"fc4bc4421f2ed388b30fd3e63cba30f66c0df331","modified":1520403073328},{"_id":"themes/cactus/layout/_partial/footer.ejs","hash":"43807dbc8cac9ed417cd98c75e7b52d35dc62f25","modified":1532073117684},{"_id":"themes/cactus/layout/_partial/header.ejs","hash":"b2cf7cdb39a99ff81342c6c62a1c879503f539a2","modified":1520403073331},{"_id":"themes/cactus/layout/_partial/head.ejs","hash":"6ac7635f5a8b55288cc6f57d05db88abb3d359d6","modified":1520403073330},{"_id":"themes/cactus/layout/_partial/pagination.ejs","hash":"f561e68e9dd10ae1cf2e79e8425f7e9b86ed723e","modified":1520403073332},{"_id":"themes/cactus/layout/_partial/scripts.ejs","hash":"6caea8fe259ddc606984c582822b9802654b970b","modified":1520403073340},{"_id":"themes/cactus/layout/_partial/styles.ejs","hash":"3670ce694a7414be4367e337959af67125bca71e","modified":1520403073342},{"_id":"themes/cactus/layout/_partial/search.ejs","hash":"12dba799ae5736dfbf1548e1923bbb7447de8a6d","modified":1520403073341},{"_id":"themes/cactus/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1520403073410},{"_id":"themes/cactus/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1520403073409},{"_id":"themes/cactus/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1520403073411},{"_id":"themes/cactus/source/css/_fonts.styl","hash":"5c1727836f5d6076a65cf91dbbeaba8d16b5132b","modified":1520403073358},{"_id":"themes/cactus/source/css/_extend.styl","hash":"8d613c64ed48ff115abd61f7ac12c19310f8cc09","modified":1520403073357},{"_id":"themes/cactus/source/css/_mixins.styl","hash":"37093d2a554283ab652b59e5e0ff9b542edced0f","modified":1520403073393},{"_id":"themes/cactus/source/css/_util.styl","hash":"1c7bed7376f04d7b77d817e132aee08cf65e6395","modified":1520403073406},{"_id":"themes/cactus/source/css/_variables.styl","hash":"e0fadb9bfea64707d2e36fa3de01edba9dc4ce1d","modified":1520403073407},{"_id":"themes/cactus/source/css/style.styl","hash":"adff86b0e4b20ed2bf7c88633edec9b3d1f2de60","modified":1520403073408},{"_id":"themes/cactus/source/js/main.js","hash":"c14636a2012047ace3a0591b337ad8504b9202b3","modified":1520403073418},{"_id":"themes/cactus/source/js/search.js","hash":"21c34118d0444d38eefc2a917db776e6735f6a38","modified":1520403073419},{"_id":"themes/cactus/layout/_partial/post/actions_desktop.ejs","hash":"684ab77be954f73853ee9407567b4c5c0ef6af74","modified":1520403073333},{"_id":"themes/cactus/layout/_partial/post/actions_mobile.ejs","hash":"c8d06799755147a64cdd0cb2728d3ce46a044dae","modified":1520403073334},{"_id":"themes/cactus/layout/_partial/post/date.ejs","hash":"1e4023733ab7f1321c2d6ff75d358f3e49b6e42c","modified":1520403073335},{"_id":"themes/cactus/layout/_partial/post/gallery.ejs","hash":"725ab823c2fb4a5e444eca3afa617d88f305ef71","modified":1520403073336},{"_id":"themes/cactus/layout/_partial/post/share.ejs","hash":"062bdcea5efc37cd7cd3478e4ff0a97db6be3fb1","modified":1520403073337},{"_id":"themes/cactus/layout/_partial/post/tag.ejs","hash":"98fe03d5a8835dbc22869d519cc5b5f48808b1e5","modified":1520403073338},{"_id":"themes/cactus/layout/_partial/post/title.ejs","hash":"67da1757316408a72393e6d2aab4ec635e1d30c1","modified":1520403073339},{"_id":"themes/cactus/source/css/_colors/classic.styl","hash":"e5f53f75e4f77a3d0b9e6221d5fd852bc820bd5e","modified":1520403073353},{"_id":"themes/cactus/source/css/_colors/dark.styl","hash":"5af8eb7cb2544350545b01990b79165dd2eab892","modified":1520403073354},{"_id":"themes/cactus/source/css/_colors/white.styl","hash":"29ef85c2de118d25418405f85a8bcf261922629f","modified":1520403073356},{"_id":"themes/cactus/source/css/_colors/light.styl","hash":"acb448dd14f004f043f0ce43c1c00c766103a5d9","modified":1520403073355},{"_id":"themes/cactus/source/css/_highlight/agate.styl","hash":"fc289ba8f47ead6331ec3a51533cfa93251c5634","modified":1520403073359},{"_id":"themes/cactus/source/css/_highlight/androidstudio.styl","hash":"4d67bdab6cc9c614486ca42f98199a04d053e7f0","modified":1520403073360},{"_id":"themes/cactus/source/css/_highlight/arta.styl","hash":"262167aaebcf28de7f85af7ac77a76fa1fa284f7","modified":1520403073361},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-dark.styl","hash":"7e83c7f2acaaaa98864660afe2794745c36c8e51","modified":1520403073361},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-dark.styl","hash":"68584ed0e99c7d0e49ef8a2e67cd4dcdad359de4","modified":1520403073362},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-dark.styl","hash":"1cecd13e0d6b24042ff86372f0596c1441bb834a","modified":1520403073364},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-dark.styl","hash":"a741eba35cdfe2cfd67dfbf109655f253d6b4795","modified":1520403073365},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-dark.styl","hash":"f186b357dcebded89b7bcc77389b2cff76533d72","modified":1520403073366},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"802979cea895a0a384645cb30a43de9572cb0e3f","modified":1520403073367},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-dark.styl","hash":"0d51ddc580ccb0a291271fa9632bc91dab632df6","modified":1520403073368},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-dark.styl","hash":"bbad7a9512b4873294e73ce806e36e43973e6ed8","modified":1520403073369},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-dark.styl","hash":"2f008271299042f2443bca98c9bcadbc8c45e837","modified":1520403073370},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"18dcb00ab9c62eb810d492047214331c51bb654f","modified":1520403073371},{"_id":"themes/cactus/source/css/_highlight/dark.styl","hash":"98d7884806838a0b46132d759d60ac27c0c4bd9c","modified":1520403073373},{"_id":"themes/cactus/source/css/_highlight/darkula.styl","hash":"8965ad6920601c275ca97e617beff5536925a266","modified":1520403073373},{"_id":"themes/cactus/source/css/_highlight/far.styl","hash":"8da83d66724f2ce508a40f21b4f6dc0d704be562","modified":1520403073374},{"_id":"themes/cactus/source/css/_highlight/codepen-embed.styl","hash":"1de45e603e2c71c7f6b0c1372a3ba00b1bc153a8","modified":1520403073371},{"_id":"themes/cactus/source/css/_highlight/hybrid.styl","hash":"4906456025787de04b48a87c42bb704c5ff67065","modified":1520403073376},{"_id":"themes/cactus/source/css/_highlight/ir-black.styl","hash":"aa31b30069ebee39e2c3ebb75e2c96ba8678eb14","modified":1520403073377},{"_id":"themes/cactus/source/css/_highlight/hopscotch.styl","hash":"dd3c78c42d4a865f11623235e5e5f6829d789706","modified":1520403073375},{"_id":"themes/cactus/source/css/_highlight/kimbie.styl","hash":"13113af220dfed09cb49d85102babb352c3eff97","modified":1520403073378},{"_id":"themes/cactus/source/css/_highlight/monokai.styl","hash":"c3a3bfae1eb864505fbc8748db734600057af1af","modified":1520403073380},{"_id":"themes/cactus/source/css/_highlight/obsidian.styl","hash":"efba069860181d2b709e1548dd16cf102ca267fa","modified":1520403073381},{"_id":"themes/cactus/source/css/_highlight/monokai-sublime.styl","hash":"84a27bd29d939105d65f4164c219d6cc2e09ae60","modified":1520403073379},{"_id":"themes/cactus/source/css/_highlight/paraiso.styl","hash":"846a06a57fa0b3db7f83ec7ac2bf34911f32cf66","modified":1520403073382},{"_id":"themes/cactus/source/css/_highlight/pojoaque.styl","hash":"4d4a9360c35f3c5a0c5b9b49a1f2284e7e21317b","modified":1520403073383},{"_id":"themes/cactus/source/css/_highlight/railscasts.styl","hash":"5dc9ce33cecee87fe9ca8f2ed9342602194484ec","modified":1520403073384},{"_id":"themes/cactus/source/css/_highlight/rainbow.styl","hash":"95246afef181bd96f9adb1a2e84fb3ef302d4598","modified":1520403073385},{"_id":"themes/cactus/source/css/_highlight/solarized-dark.styl","hash":"9fc9400d3a8cae97eb5761c284140acb0f847538","modified":1520403073386},{"_id":"themes/cactus/source/css/_highlight/sunburst.styl","hash":"e6e4c009b10b9805f0c593446bf013edec47d146","modified":1520403073387},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-blue.styl","hash":"92f4423d4964fcfe34ff7ca6cb21012b5738c697","modified":1520403073388},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night.styl","hash":"eb8441364bb1664ecebde77b965dc36c91133aa0","modified":1520403073391},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-bright.styl","hash":"e6b025b247e4027fb3c1b7833588f5a5b04a549c","modified":1520403073389},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"8b16876cf205111d5d5454100de712bc3ea8f477","modified":1520403073390},{"_id":"themes/cactus/source/css/_highlight/zenburn.styl","hash":"f63534764dd6598e81177d64714a184f98153b11","modified":1520403073392},{"_id":"themes/cactus/source/css/_partial/archive.styl","hash":"c89529b82ff8bd059384aedf36e7690a9a67da7a","modified":1520403073395},{"_id":"themes/cactus/source/css/_partial/article.styl","hash":"d2df5199134aceea4cedf403699dd0650879a96e","modified":1520403073396},{"_id":"themes/cactus/source/css/_partial/footer.styl","hash":"b81c1718b398fc940646435fb4398278181f6643","modified":1520403073397},{"_id":"themes/cactus/source/css/_partial/comments.styl","hash":"6e839bae0ddc11447579c34541e79b50d3670bbd","modified":1520403073396},{"_id":"themes/cactus/source/css/_partial/header.styl","hash":"3b24a8844fd5e53d595f7157d3906822a2f61085","modified":1520403073398},{"_id":"themes/cactus/source/css/_partial/index.styl","hash":"5c02d1258bdcec4fccbaa4afc41f8b699f5d506c","modified":1520403073400},{"_id":"themes/cactus/source/css/_partial/pagination.styl","hash":"4ff9755163aae6039bb72eac8360bc1c50fa26b6","modified":1520403073401},{"_id":"themes/cactus/source/css/_partial/search.styl","hash":"680ea535e5a20c01a31bee4d3eb680b86267a281","modified":1520403073404},{"_id":"themes/cactus/source/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1520403073414},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","hash":"0c3192b500a4fd550e483cf77a49806a5872185b","modified":1520403073449},{"_id":"themes/cactus/source/css/_partial/post/actions_mobile.styl","hash":"b06410ed34b5ecbcac11357aa359149e1f827aa6","modified":1520403073404},{"_id":"themes/cactus/source/css/_partial/post/actions_desktop.styl","hash":"f6f13b3b23f5dd6a5513010234468e783c010d98","modified":1520403073403},{"_id":"themes/cactus/source/lib/font-awesome/css/fontawesome-all.min.css","hash":"8c2f2563fded26178c1c5d938fc5984ace011ceb","modified":1520403073421},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"065d1184f7256fc4897a1c3023a361b2491282e1","modified":1520403073431},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"74b3228a2cc98d96ddcd095915dd770c27cd2858","modified":1520403073434},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"b2258ca3824c7e0a03efe19edc10d54571fcf0b4","modified":1520403073432},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"45bb0eb8b57b864dbf7da820fd8dc17b296753ee","modified":1520403073437},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"09fe1eedfc1378d20828d07cbaf0a15284757211","modified":1520403073438},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"28844ababc02fe5cea50bec9321da0a492ce1369","modified":1520403073439},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"05d552c1d360502f134a3aa37580373b14d65797","modified":1520403073446},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"7a4c38d80cab424875ffcfc090ad3941e0f7a4cf","modified":1520403073447},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","hash":"a0d5cad0c2382b027167a21b82356d98f71358aa","modified":1520403073451},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"8287f3d06459017b12337827ef1899ee073dc245","modified":1520403073452},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"f92896ce0243daa72a6bd71a026ed7c9906f921e","modified":1520403073424},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"f9f34b664f8bf760f3f848d6a31d14ab0e029993","modified":1520403073430},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"188b96d4e537f1f32894f4be20c1bb3478f65a68","modified":1520403073436},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"d775b9bf2ea3da471494a684baa56e312e906884","modified":1520403073440},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"54d03b85192ebeaa6d34e680326bd4c0e1322296","modified":1520403073445},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1520403073461},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1520403073479},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1520403073497},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1520403073465},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1520403073483},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1520403073501},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"cc2afb88e00fe8b66c5dc399dbc320760517e12c","modified":1520403073443},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1520403073457},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1520403073470},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1520403073475},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1520403073488},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1520403073493},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1520403073506},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"fd5ac0a6f2a6dfcbc8c08aee327196e009453d6d","modified":1520403073428},{"_id":"public/2018/03/07/migrate-to-hexo/index.html","hash":"6703c036f5e828138815c8696c950b939d31f1bb","modified":1532073286922},{"_id":"public/2015/12/22/cpp-cast/index.html","hash":"573b64e37685f98b796f10827734365e4f551b89","modified":1532073252082},{"_id":"public/2015/04/01/android-pre-compiler-error/index.html","hash":"3696148e901ba06d5d6310517fb0d0aee02e51bc","modified":1532073252082},{"_id":"public/2014/06/24/MP4-to-HLS-based-on-nginx-http-mp4-module/index.html","hash":"11a23c4f2c1f626958063413e7080a58ee4a3388","modified":1532073252086},{"_id":"public/2013/11/27/xauth_with_node/index.html","hash":"5c045f32a9ae94a38f8498730c721aed8dffe8e1","modified":1532073252082},{"_id":"public/2013/10/10/write-blog-with-prose/index.html","hash":"544a6b5adb2e28089f2a1f278a78cba351c9a89d","modified":1532073252082},{"_id":"public/2013/10/10/ffmpeg-mosaic/index.html","hash":"b05edaae368625e20e1258e83a7b5747d3c82d26","modified":1532073252082},{"_id":"public/2013/11/27/riders_resume/index.html","hash":"0b98cc97f437f8ac079fa4b0e9bd366c57da3d92","modified":1532073252082},{"_id":"public/2013/10/11/from-wordpress-to-github/index.html","hash":"88c95e80ec79b8ba1b5f8f2648976b131d2bf690","modified":1532073252082},{"_id":"public/2013/09/30/fix-ffmpeg-librtmp-not-found/index.html","hash":"df3c2812a0f04f20498f4d22db0a29ce806bac24","modified":1532073252082},{"_id":"public/2013/09/29/fix-nexus-7-2013-otg-storage/index.html","hash":"5db791a2d82787b5aa0d6e58dfb17fbf57732968","modified":1532073252082},{"_id":"public/2013/09/26/something-about-nginx-and-hls/index.html","hash":"683c24707bc214fcfc4b9d194033770ccdd66658","modified":1532073252082},{"_id":"public/2013/07/27/boost-property_tree-threadsafe/index.html","hash":"d65d2f44bf2de31cae162087c4a7fbdf9dd2aec8","modified":1532073252082},{"_id":"public/2013/07/20/delpoy-bottle-to-gae/index.html","hash":"efa9ad750b0aba84a1276b52328c84f9f853aaaa","modified":1532073252082},{"_id":"public/2013/04/03/deps/index.html","hash":"afe1171ebedbfa89c069493f76b0cf693897c4df","modified":1532073252082},{"_id":"public/2013/03/26/new-post/index.html","hash":"be772dc073f667a0715a69f61646c748ed8825fc","modified":1532073252082},{"_id":"public/2013/04/12/cpp_standard_library_string_find_and_npos_usage/index.html","hash":"e478084ee21ef68994c722ee5faa5d3d8c09708e","modified":1532073252082},{"_id":"public/2013/04/01/unreliable-backtrace/index.html","hash":"d51b7aaf73dd3b8da70ba449570513f6a15c943d","modified":1532073252082},{"_id":"public/archives/index.html","hash":"dc846130a195efce663f1b65f9157871ccf9d20a","modified":1532073252082},{"_id":"public/archives/page/2/index.html","hash":"1890aaeb1fa982bf8cc333626f9c58c73a597342","modified":1532073252083},{"_id":"public/archives/2013/index.html","hash":"c871708a2922efb4faae54a60f5c7279124816cb","modified":1532073252083},{"_id":"public/archives/2013/03/index.html","hash":"3e4a441d5221d0d49010e45d1abfc7f781ebf00d","modified":1532073252084},{"_id":"public/archives/2013/page/2/index.html","hash":"82d68c9e12217e9cd53b251141729f19e39dc221","modified":1532073252083},{"_id":"public/archives/2013/04/index.html","hash":"cb485de696dc735ee02e14f964f8449fbe8ab4e8","modified":1532073252084},{"_id":"public/archives/2013/07/index.html","hash":"41882d06c903842ddcd410729cee9dc5caa82a3c","modified":1532073252084},{"_id":"public/archives/2013/09/index.html","hash":"5353bb33c8f2275418eef1827d149e69991b9854","modified":1532073252084},{"_id":"public/archives/2013/10/index.html","hash":"da3ec9a7f2ec32a7a9340e8aebdb7f750c4eb6a9","modified":1532073252084},{"_id":"public/archives/2013/11/index.html","hash":"2f02155278acc5c0dc6b18c955eba809bb9bca21","modified":1532073252084},{"_id":"public/archives/2014/index.html","hash":"b850df555e2e658e09c5c5e57c46d508c45bf811","modified":1532073252084},{"_id":"public/archives/2014/06/index.html","hash":"cbb90e53e3f08d93b48a2120ef4107b622c7b94d","modified":1532073252084},{"_id":"public/archives/2015/index.html","hash":"d2bffa665ceeced27421d6d0c2acaf6c90882ffe","modified":1532073252084},{"_id":"public/archives/2015/04/index.html","hash":"b01c2b50b8173ea82b1cda4a6b3488e03aa6f630","modified":1532073252084},{"_id":"public/archives/2015/12/index.html","hash":"30635afbfc656f164c6d15ec6511ea779eecfc7a","modified":1532073252084},{"_id":"public/archives/2018/index.html","hash":"b140903d31c183b1b5f71e9a11ddf3bd07f8feac","modified":1532073252084},{"_id":"public/archives/2018/03/index.html","hash":"6404e8e9bfc8e57eca5aa19b14c9c5050f1be8d4","modified":1532073252084},{"_id":"public/page/2/index.html","hash":"ecd9ac676ed6e9b9be2fdd79ec257d3ef22a50c3","modified":1532073252084},{"_id":"public/index.html","hash":"dfd47f57ead5169558c5ec75d9ce2d937236e721","modified":1532073252084},{"_id":"public/tags/GAE/index.html","hash":"d28d2a066c83d0141406982eac0a7fcb23b3e918","modified":1532073252085},{"_id":"public/tags/bottle/index.html","hash":"f320be3404b86784dab81d2a416c87df310f1a5e","modified":1532073252084},{"_id":"public/tags/boost/index.html","hash":"e1b0e36b691d7def1899d3dfdbcf92f5cf9a6ca6","modified":1532073252085},{"_id":"public/tags/property-tree/index.html","hash":"777aef231690bbc221993e90e5f3fba207c2259c","modified":1532073252085},{"_id":"public/tags/threadsafe/index.html","hash":"fd03f689ada58cf209433cad53e110a5d9db4649","modified":1532073252085},{"_id":"public/tags/read-json/index.html","hash":"970282d9f072286b8e414d64ae1d8f819f6af649","modified":1532073252085},{"_id":"public/tags/nginx/index.html","hash":"55dada4ed7e1e9cffc8d9790113d864dbb7aa94f","modified":1532073252085},{"_id":"public/2014/06/24/HTTP-Live-Streaming-notes/index.html","hash":"cb626949cac0071b80e502a5205ff19f69b49902","modified":1532073252086},{"_id":"public/2013/07/23/nginx-rtmp-module-summary/index.html","hash":"e935c26325a259c87041214ac1cd777b97783057","modified":1532073252086},{"_id":"public/2018/03/07/PowerShell-font/index.html","hash":"3d251ba0224709971ae8dca68b778632a6f921e0","modified":1532073252081},{"_id":"public/archives/page/3/index.html","hash":"b36084cc048640a6a4f0a0248a60ed1313609267","modified":1532073252083},{"_id":"public/page/3/index.html","hash":"91da84ca15523e888df185d4b65e5997c0e8f6cb","modified":1532073252084},{"_id":"public/tags/HLS/index.html","hash":"53dcf8d1d644378fac152c7d573c34af2c180e0e","modified":1532073252085},{"_id":"public/tags/ffmpeg/index.html","hash":"a2729b7760154918d44b7df40af3bee354d894c5","modified":1532073252085},{"_id":"public/tags/rtmp/index.html","hash":"33a5a8f5a45f4666c65bd3037514005262210c55","modified":1532073252085},{"_id":"public/tags/librtmp/index.html","hash":"df985122bd1f6ff30334f33936de39f8e66f3064","modified":1532073252085},{"_id":"public/tags/Nexus/index.html","hash":"043e402bc54a1bc8bf350e956ddb059f69473363","modified":1532073252085},{"_id":"public/tags/wordpress/index.html","hash":"993db97f9233efbbf1f1761c8eb791dd6c22cc0b","modified":1532073252085},{"_id":"public/tags/OTG/index.html","hash":"1afdddcd414af0b319fb08d2c183f461d9b4a3ae","modified":1532073252085},{"_id":"public/tags/resume/index.html","hash":"92343aa20a1e1f2bff985b6682271fec2ba4d867","modified":1532073252085},{"_id":"public/tags/node/index.html","hash":"63682f818ed0635b7ea129da7e31d68d5189de2e","modified":1532073252086},{"_id":"public/tags/eclipse/index.html","hash":"149a0dbc0364492ff948732a96ba849024f36644","modified":1532073252086},{"_id":"public/tags/android/index.html","hash":"91d5a6ec16c7a1d1bb388cef0ff0cbab0b8c13dc","modified":1532073252086},{"_id":"public/tags/xauth/index.html","hash":"41e2e5eee57527ec9c93133ed788a1e0a5952d47","modified":1532073252086},{"_id":"public/tags/fanfou/index.html","hash":"68abe1bec7c336a79a73bea29b9570a5c9239bc1","modified":1532073252086},{"_id":"public/tags/c/index.html","hash":"b1df2ac61c5214cbe666cea07b5fbcd1c9a1b3c8","modified":1532073252086},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1520403234050},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1520403234051},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1520403234051},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"065d1184f7256fc4897a1c3023a361b2491282e1","modified":1520403234051},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"74b3228a2cc98d96ddcd095915dd770c27cd2858","modified":1520403234051},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"28844ababc02fe5cea50bec9321da0a492ce1369","modified":1520403234052},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"45bb0eb8b57b864dbf7da820fd8dc17b296753ee","modified":1520403234052},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"b2258ca3824c7e0a03efe19edc10d54571fcf0b4","modified":1520403234052},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"09fe1eedfc1378d20828d07cbaf0a15284757211","modified":1520403234052},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"05d552c1d360502f134a3aa37580373b14d65797","modified":1520403234052},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"7a4c38d80cab424875ffcfc090ad3941e0f7a4cf","modified":1520403234052},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"f92896ce0243daa72a6bd71a026ed7c9906f921e","modified":1520403234536},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"f9f34b664f8bf760f3f848d6a31d14ab0e029993","modified":1520403234539},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"188b96d4e537f1f32894f4be20c1bb3478f65a68","modified":1520403234539},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"54d03b85192ebeaa6d34e680326bd4c0e1322296","modified":1520403234539},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"d775b9bf2ea3da471494a684baa56e312e906884","modified":1520403234539},{"_id":"public/js/main.js","hash":"4659a6f4e3b988034c984cf81d16623d68624118","modified":1520403234566},{"_id":"public/js/search.js","hash":"ba2947a9a6107a529f95281795bc5fa9cbc17b9f","modified":1520403234566},{"_id":"public/lib/justified-gallery/css/justifiedGallery.min.css","hash":"e7ba2de65435a0067d64f49b92a6d395cab508cc","modified":1520403234566},{"_id":"public/css/style.css","hash":"8ca2f6d2a17c318b1b355d49fec6e00181a0e7fe","modified":1520403234566},{"_id":"public/lib/jquery/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1520403234566},{"_id":"public/lib/font-awesome/css/fontawesome-all.min.css","hash":"dac0b9af15b6aa47b072469eb440cbe8fee16034","modified":1520403234566},{"_id":"public/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"1151c5ef92d121329e8ef75ea997a5b79babc00b","modified":1520403234566},{"_id":"public/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1520403234575},{"_id":"public/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1520403234594},{"_id":"public/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1520403234594},{"_id":"public/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1520403234594},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"cc2afb88e00fe8b66c5dc399dbc320760517e12c","modified":1520403234594},{"_id":"public/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1520403234599},{"_id":"public/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1520403234599},{"_id":"public/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1520403234599},{"_id":"public/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1520403234606},{"_id":"public/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1520403234606},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"fd5ac0a6f2a6dfcbc8c08aee327196e009453d6d","modified":1520403234606},{"_id":"public/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1520403234606},{"_id":"public/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1520403234607},{"_id":"public/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1520403234607},{"_id":"public/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1520403234607},{"_id":"source/_posts/2018-05-18-how-to-draw-a-peppa-pig-using-CSS.md","hash":"c004a719358504a11ae56400575ba5787da1984b","modified":1532073117671},{"_id":"public/2018/05/18/how-to-draw-a-peppa-pig-using-CSS/index.html","hash":"2ec6e33738f47558e0bbc7ae9265941f1c78a877","modified":1532073252081},{"_id":"public/archives/2018/05/index.html","hash":"601f4efc85e6a424f7d51de4e67ad514dbdc479c","modified":1532073252084}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"post","title":"new post","description":"My first post on Jekyll blog.","category":null,"_content":"\nMy first post on Jekyll blog.","source":"_posts/2013-03-26-new-post.md","raw":"---\nlayout: post\ntitle: \"new post\"\ndescription: \"My first post on Jekyll blog.\"\ncategory: \ntags: []\n---\n\nMy first post on Jekyll blog.","slug":"new-post","published":1,"date":"2013-03-25T16:00:00.000Z","updated":"2018-03-07T06:11:13.295Z","comments":1,"photos":[],"link":"","_id":"cjegotupk0000i0fobfqmslke","content":"<p>My first post on Jekyll blog.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>My first post on Jekyll blog.</p>\n"},{"layout":"post","title":"不靠谱的backtrace","description":"不靠谱的backtrace，增加日志后调试发现确实如此，backtrace报告的代码不是真正出问题的代码。","category":null,"_content":"\n#起因\n今天遇到一个问题，程序收到abort信号后退出，打开core文件后很快定位到目标代码，但是很奇怪的是目标代码似乎没有问题，反而是目标代码附近的代码看起来比较可疑。\n增加日志后调试发现确实如此，backtrace报告的代码不是真正出问题的代码。\n\n#重现\n\n    #include \"base.h\"\n    #include \"stdio.h\"\n    boost::shared_ptr<std::string> err_str;\n    boost::shared_ptr<std::string> normal_str2;\n    int main(int argc, char **argv)\n    {\n        err_str.reset();\n        normal_str2 = boost::shared_ptr<std::string>(new std::string);\n        *normal_str2 = \"test\";\n        printf(\"before\\n\");\n        std::string l_test_str = *(err_str); // !!!\n        printf(\"after\\n\");\n        printf(\"%c\\n\", normal_str2->at(0));\n        return 0;\n    }\n\n上面代码的错误很明显，使用＊获取一个空指针的值，会导致BOOST_ASSERT失败，程序会因abort信号而退出。在我的机器上，gdb告诉我，是reset的那行代码出了问题，真让人摸不着头脑。当然before还是会打印出来的。\n\n    #include \"base.h\"\n    #include \"stdio.h\"\n    boost::shared_ptr<std::string> err_str;\n    boost::shared_ptr<std::string> normal_str2;\n    int main(int argc, char **argv)\n    {\n        err_str.reset();\n        normal_str2 = boost::shared_ptr<std::string>(new std::string);\n        *normal_str2 = \"test\";\n        printf(\"before\\n\");\n        assert(err_str.get()); // !!!\n        printf(\"after\\n\");\n        printf(\"%c\\n\", normal_str2->at(0));\n        return 0;\n    }\n\n上面的代码会在错误行abort，并且backtrace给出的行号是正确的。\n\n# 结论\n相信日志吧！backtrace仅供参考。\n本人能力有限，目前只能怀疑是＊操作破坏了栈，导致backtrace报告了错误的代码位置。有心的朋友可以用objdump看看汇编代码，若找到真正原因，希望也能和我分享。谢谢！\n","source":"_posts/2013-04-01-unreliable-backtrace.md","raw":"---\nlayout: post\ntitle: \"不靠谱的backtrace\"\ndescription: \"不靠谱的backtrace，增加日志后调试发现确实如此，backtrace报告的代码不是真正出问题的代码。\"\ncategory: \ntags: []\n---\n\n#起因\n今天遇到一个问题，程序收到abort信号后退出，打开core文件后很快定位到目标代码，但是很奇怪的是目标代码似乎没有问题，反而是目标代码附近的代码看起来比较可疑。\n增加日志后调试发现确实如此，backtrace报告的代码不是真正出问题的代码。\n\n#重现\n\n    #include \"base.h\"\n    #include \"stdio.h\"\n    boost::shared_ptr<std::string> err_str;\n    boost::shared_ptr<std::string> normal_str2;\n    int main(int argc, char **argv)\n    {\n        err_str.reset();\n        normal_str2 = boost::shared_ptr<std::string>(new std::string);\n        *normal_str2 = \"test\";\n        printf(\"before\\n\");\n        std::string l_test_str = *(err_str); // !!!\n        printf(\"after\\n\");\n        printf(\"%c\\n\", normal_str2->at(0));\n        return 0;\n    }\n\n上面代码的错误很明显，使用＊获取一个空指针的值，会导致BOOST_ASSERT失败，程序会因abort信号而退出。在我的机器上，gdb告诉我，是reset的那行代码出了问题，真让人摸不着头脑。当然before还是会打印出来的。\n\n    #include \"base.h\"\n    #include \"stdio.h\"\n    boost::shared_ptr<std::string> err_str;\n    boost::shared_ptr<std::string> normal_str2;\n    int main(int argc, char **argv)\n    {\n        err_str.reset();\n        normal_str2 = boost::shared_ptr<std::string>(new std::string);\n        *normal_str2 = \"test\";\n        printf(\"before\\n\");\n        assert(err_str.get()); // !!!\n        printf(\"after\\n\");\n        printf(\"%c\\n\", normal_str2->at(0));\n        return 0;\n    }\n\n上面的代码会在错误行abort，并且backtrace给出的行号是正确的。\n\n# 结论\n相信日志吧！backtrace仅供参考。\n本人能力有限，目前只能怀疑是＊操作破坏了栈，导致backtrace报告了错误的代码位置。有心的朋友可以用objdump看看汇编代码，若找到真正原因，希望也能和我分享。谢谢！\n","slug":"unreliable-backtrace","published":1,"date":"2013-03-31T16:00:00.000Z","updated":"2018-03-07T06:11:13.296Z","comments":1,"photos":[],"link":"","_id":"cjegotupq0001i0fof4vrnhq9","content":"<p>#起因<br>今天遇到一个问题，程序收到abort信号后退出，打开core文件后很快定位到目标代码，但是很奇怪的是目标代码似乎没有问题，反而是目标代码附近的代码看起来比较可疑。<br>增加日志后调试发现确实如此，backtrace报告的代码不是真正出问题的代码。</p>\n<p>#重现</p>\n<pre><code>#include &quot;base.h&quot;\n#include &quot;stdio.h&quot;\nboost::shared_ptr&lt;std::string&gt; err_str;\nboost::shared_ptr&lt;std::string&gt; normal_str2;\nint main(int argc, char **argv)\n{\n    err_str.reset();\n    normal_str2 = boost::shared_ptr&lt;std::string&gt;(new std::string);\n    *normal_str2 = &quot;test&quot;;\n    printf(&quot;before\\n&quot;);\n    std::string l_test_str = *(err_str); // !!!\n    printf(&quot;after\\n&quot;);\n    printf(&quot;%c\\n&quot;, normal_str2-&gt;at(0));\n    return 0;\n}\n</code></pre><p>上面代码的错误很明显，使用＊获取一个空指针的值，会导致BOOST_ASSERT失败，程序会因abort信号而退出。在我的机器上，gdb告诉我，是reset的那行代码出了问题，真让人摸不着头脑。当然before还是会打印出来的。</p>\n<pre><code>#include &quot;base.h&quot;\n#include &quot;stdio.h&quot;\nboost::shared_ptr&lt;std::string&gt; err_str;\nboost::shared_ptr&lt;std::string&gt; normal_str2;\nint main(int argc, char **argv)\n{\n    err_str.reset();\n    normal_str2 = boost::shared_ptr&lt;std::string&gt;(new std::string);\n    *normal_str2 = &quot;test&quot;;\n    printf(&quot;before\\n&quot;);\n    assert(err_str.get()); // !!!\n    printf(&quot;after\\n&quot;);\n    printf(&quot;%c\\n&quot;, normal_str2-&gt;at(0));\n    return 0;\n}\n</code></pre><p>上面的代码会在错误行abort，并且backtrace给出的行号是正确的。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>相信日志吧！backtrace仅供参考。<br>本人能力有限，目前只能怀疑是＊操作破坏了栈，导致backtrace报告了错误的代码位置。有心的朋友可以用objdump看看汇编代码，若找到真正原因，希望也能和我分享。谢谢！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#起因<br>今天遇到一个问题，程序收到abort信号后退出，打开core文件后很快定位到目标代码，但是很奇怪的是目标代码似乎没有问题，反而是目标代码附近的代码看起来比较可疑。<br>增加日志后调试发现确实如此，backtrace报告的代码不是真正出问题的代码。</p>\n<p>#重现</p>\n<pre><code>#include &quot;base.h&quot;\n#include &quot;stdio.h&quot;\nboost::shared_ptr&lt;std::string&gt; err_str;\nboost::shared_ptr&lt;std::string&gt; normal_str2;\nint main(int argc, char **argv)\n{\n    err_str.reset();\n    normal_str2 = boost::shared_ptr&lt;std::string&gt;(new std::string);\n    *normal_str2 = &quot;test&quot;;\n    printf(&quot;before\\n&quot;);\n    std::string l_test_str = *(err_str); // !!!\n    printf(&quot;after\\n&quot;);\n    printf(&quot;%c\\n&quot;, normal_str2-&gt;at(0));\n    return 0;\n}\n</code></pre><p>上面代码的错误很明显，使用＊获取一个空指针的值，会导致BOOST_ASSERT失败，程序会因abort信号而退出。在我的机器上，gdb告诉我，是reset的那行代码出了问题，真让人摸不着头脑。当然before还是会打印出来的。</p>\n<pre><code>#include &quot;base.h&quot;\n#include &quot;stdio.h&quot;\nboost::shared_ptr&lt;std::string&gt; err_str;\nboost::shared_ptr&lt;std::string&gt; normal_str2;\nint main(int argc, char **argv)\n{\n    err_str.reset();\n    normal_str2 = boost::shared_ptr&lt;std::string&gt;(new std::string);\n    *normal_str2 = &quot;test&quot;;\n    printf(&quot;before\\n&quot;);\n    assert(err_str.get()); // !!!\n    printf(&quot;after\\n&quot;);\n    printf(&quot;%c\\n&quot;, normal_str2-&gt;at(0));\n    return 0;\n}\n</code></pre><p>上面的代码会在错误行abort，并且backtrace给出的行号是正确的。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>相信日志吧！backtrace仅供参考。<br>本人能力有限，目前只能怀疑是＊操作破坏了栈，导致backtrace报告了错误的代码位置。有心的朋友可以用objdump看看汇编代码，若找到真正原因，希望也能和我分享。谢谢！</p>\n"},{"layout":"post","title":"Delpoy Bottle To GAE","description":"少走一些弯路","category":null,"_content":"\n1. 创建framework目录，并创建framework/__init__.py文件，拷贝bottle.py到framework/中\n2. 修改app.yaml如下：\n\n    \tapplication: YOUR_APP_NAME\n\t\tversion: 1\n\t\truntime: python27\n\t\tapi_version: 1\n\t\tthreadsafe: yes\n\t\n\t\thandlers:\n\t\t\t- url: /favicon\\.ico\n  \t\t\tstatic_files: favicon.ico\n  \t\t\tupload: favicon\\.ico\n\n\t\t\t- url: /.*\n  \t\t\tscript: main.app\n\n\n3. 修改main.py如下：\n\n\t\t#!/usr/bin/env python\n\t\tfrom framework import bottle\n\t\tfrom framework.bottle import *\n\t\t\n\t\tapp = Bottle()\n\t\t@app.get('/')\n\t\tdef DisplayForm():\n\t\t    return \"Hello World\"\n\t\t \n\t\tbottle.run(app=app, server='gae')\n\t\t\n\n另外，也可以参考[这里](http://petergao.com/blog/using-bottle-with-python2-7-on-google-app-engine/)的介绍。","source":"_posts/2013-07-20-delpoy-bottle-to-gae.md","raw":"---\nlayout: post\ntitle: \"Delpoy Bottle To GAE\"\ndescription: \"少走一些弯路\"\ncategory: \ntags: [bottle, GAE]\n---\n\n1. 创建framework目录，并创建framework/__init__.py文件，拷贝bottle.py到framework/中\n2. 修改app.yaml如下：\n\n    \tapplication: YOUR_APP_NAME\n\t\tversion: 1\n\t\truntime: python27\n\t\tapi_version: 1\n\t\tthreadsafe: yes\n\t\n\t\thandlers:\n\t\t\t- url: /favicon\\.ico\n  \t\t\tstatic_files: favicon.ico\n  \t\t\tupload: favicon\\.ico\n\n\t\t\t- url: /.*\n  \t\t\tscript: main.app\n\n\n3. 修改main.py如下：\n\n\t\t#!/usr/bin/env python\n\t\tfrom framework import bottle\n\t\tfrom framework.bottle import *\n\t\t\n\t\tapp = Bottle()\n\t\t@app.get('/')\n\t\tdef DisplayForm():\n\t\t    return \"Hello World\"\n\t\t \n\t\tbottle.run(app=app, server='gae')\n\t\t\n\n另外，也可以参考[这里](http://petergao.com/blog/using-bottle-with-python2-7-on-google-app-engine/)的介绍。","slug":"delpoy-bottle-to-gae","published":1,"date":"2013-07-19T16:00:00.000Z","updated":"2018-03-07T06:11:13.299Z","comments":1,"photos":[],"link":"","_id":"cjegotupw0002i0fori4aivys","content":"<ol>\n<li>创建framework目录，并创建framework/<strong>init</strong>.py文件，拷贝bottle.py到framework/中</li>\n<li><p>修改app.yaml如下：</p>\n<pre><code>application: YOUR_APP_NAME\nversion: 1\nruntime: python27\napi_version: 1\nthreadsafe: yes\n\nhandlers:\n    - url: /favicon\\.ico\n      static_files: favicon.ico\n      upload: favicon\\.ico\n\n    - url: /.*\n      script: main.app\n</code></pre></li>\n</ol>\n<ol>\n<li><p>修改main.py如下：</p>\n<pre><code>#!/usr/bin/env python\nfrom framework import bottle\nfrom framework.bottle import *\n\napp = Bottle()\n@app.get(&apos;/&apos;)\ndef DisplayForm():\n    return &quot;Hello World&quot;\n\nbottle.run(app=app, server=&apos;gae&apos;)\n</code></pre></li>\n</ol>\n<p>另外，也可以参考<a href=\"http://petergao.com/blog/using-bottle-with-python2-7-on-google-app-engine/\" target=\"_blank\" rel=\"noopener\">这里</a>的介绍。</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>创建framework目录，并创建framework/<strong>init</strong>.py文件，拷贝bottle.py到framework/中</li>\n<li><p>修改app.yaml如下：</p>\n<pre><code>application: YOUR_APP_NAME\nversion: 1\nruntime: python27\napi_version: 1\nthreadsafe: yes\n\nhandlers:\n    - url: /favicon\\.ico\n      static_files: favicon.ico\n      upload: favicon\\.ico\n\n    - url: /.*\n      script: main.app\n</code></pre></li>\n</ol>\n<ol>\n<li><p>修改main.py如下：</p>\n<pre><code>#!/usr/bin/env python\nfrom framework import bottle\nfrom framework.bottle import *\n\napp = Bottle()\n@app.get(&apos;/&apos;)\ndef DisplayForm():\n    return &quot;Hello World&quot;\n\nbottle.run(app=app, server=&apos;gae&apos;)\n</code></pre></li>\n</ol>\n<p>另外，也可以参考<a href=\"http://petergao.com/blog/using-bottle-with-python2-7-on-google-app-engine/\" target=\"_blank\" rel=\"noopener\">这里</a>的介绍。</p>\n"},{"layout":"post","title":"一些.deps文件未更新导致的问题","description":"使用aclocal重新构建了项目，但一些.deps文件未更新。","category":null,"_content":"\n项目中有一个c文件，需要导入到c++项目中，并改为cpp文件。\n\n改了Makefile.am中\\*\\*_SOURCES，用aclocal那一套重新构建了项目，但是编译的时候，make仍然去找原来的c文件，而不是已经改名的cpp文件。\n\n反复确认后发现，项目目录下的.deps目录下相应的.Po文件中的依赖关系没有跟随\\*\\*_SOURCES更新，删除.deps文件夹，重新make，问题解决。\n","source":"_posts/2013-04-03-deps.md","raw":"---\nlayout: post\ntitle: \"一些.deps文件未更新导致的问题\"\ndescription: \"使用aclocal重新构建了项目，但一些.deps文件未更新。\"\ncategory: \ntags: []\n---\n\n项目中有一个c文件，需要导入到c++项目中，并改为cpp文件。\n\n改了Makefile.am中\\*\\*_SOURCES，用aclocal那一套重新构建了项目，但是编译的时候，make仍然去找原来的c文件，而不是已经改名的cpp文件。\n\n反复确认后发现，项目目录下的.deps目录下相应的.Po文件中的依赖关系没有跟随\\*\\*_SOURCES更新，删除.deps文件夹，重新make，问题解决。\n","slug":"deps","published":1,"date":"2013-04-02T16:00:00.000Z","updated":"2018-03-07T06:11:13.297Z","comments":1,"photos":[],"link":"","_id":"cjegotupy0003i0fozmgrdy1w","content":"<p>项目中有一个c文件，需要导入到c++项目中，并改为cpp文件。</p>\n<p>改了Makefile.am中**_SOURCES，用aclocal那一套重新构建了项目，但是编译的时候，make仍然去找原来的c文件，而不是已经改名的cpp文件。</p>\n<p>反复确认后发现，项目目录下的.deps目录下相应的.Po文件中的依赖关系没有跟随**_SOURCES更新，删除.deps文件夹，重新make，问题解决。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目中有一个c文件，需要导入到c++项目中，并改为cpp文件。</p>\n<p>改了Makefile.am中**_SOURCES，用aclocal那一套重新构建了项目，但是编译的时候，make仍然去找原来的c文件，而不是已经改名的cpp文件。</p>\n<p>反复确认后发现，项目目录下的.deps目录下相应的.Po文件中的依赖关系没有跟随**_SOURCES更新，删除.deps文件夹，重新make，问题解决。</p>\n"},{"layout":"post","title":"boost::property_tree threadsafe","description":"增加宏定义解决boost::property_tree的线程安全问题","category":null,"_content":"\n##问题描述：\n最近程序经常崩溃，GDB调试发现全部是read_json函数调用的问题。\n\n##问题原因：\nboost::property_tree是boost提供的文本解析库，可用于解析或生成json，xml，ini等文件。\n\nproperty_tree依赖grammar库，grammar在多线程环境下使用（很）可能崩溃。\n\n##问题解决：\n引用与property_tree头文件之前定义宏：\n\t\n\t#define BOOST_SPIRIT_THREADSAFE\n\t\n效果非常显著，建议把宏的定义直接写入Makefile。","source":"_posts/2013-07-27-boost-property_tree-threadsafe.md","raw":"---\nlayout: post\ntitle: \"boost::property_tree threadsafe\"\ndescription: \"增加宏定义解决boost::property_tree的线程安全问题\"\ncategory: \ntags: [boost, property_tree, read_json, threadsafe]\n---\n\n##问题描述：\n最近程序经常崩溃，GDB调试发现全部是read_json函数调用的问题。\n\n##问题原因：\nboost::property_tree是boost提供的文本解析库，可用于解析或生成json，xml，ini等文件。\n\nproperty_tree依赖grammar库，grammar在多线程环境下使用（很）可能崩溃。\n\n##问题解决：\n引用与property_tree头文件之前定义宏：\n\t\n\t#define BOOST_SPIRIT_THREADSAFE\n\t\n效果非常显著，建议把宏的定义直接写入Makefile。","slug":"boost-property_tree-threadsafe","published":1,"date":"2013-07-26T16:00:00.000Z","updated":"2018-03-07T06:11:13.302Z","comments":1,"photos":[],"link":"","_id":"cjegotuq50005i0foo5vod9gu","content":"<p>##问题描述：<br>最近程序经常崩溃，GDB调试发现全部是read_json函数调用的问题。</p>\n<p>##问题原因：<br>boost::property_tree是boost提供的文本解析库，可用于解析或生成json，xml，ini等文件。</p>\n<p>property_tree依赖grammar库，grammar在多线程环境下使用（很）可能崩溃。</p>\n<p>##问题解决：<br>引用与property_tree头文件之前定义宏：</p>\n<pre><code>#define BOOST_SPIRIT_THREADSAFE\n</code></pre><p>效果非常显著，建议把宏的定义直接写入Makefile。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##问题描述：<br>最近程序经常崩溃，GDB调试发现全部是read_json函数调用的问题。</p>\n<p>##问题原因：<br>boost::property_tree是boost提供的文本解析库，可用于解析或生成json，xml，ini等文件。</p>\n<p>property_tree依赖grammar库，grammar在多线程环境下使用（很）可能崩溃。</p>\n<p>##问题解决：<br>引用与property_tree头文件之前定义宏：</p>\n<pre><code>#define BOOST_SPIRIT_THREADSAFE\n</code></pre><p>效果非常显著，建议把宏的定义直接写入Makefile。</p>\n"},{"layout":"post","title":"Something About Nginx and HLS","description":"nginx作为hls服务器时需要考虑的问题","category":null,"_content":"\n不涉及具体实现，只是总结一下近半个月来研究nginx和HLS以及综合两者时遇到的一些困难。\n\n## ngx_open_cached_file()\n\n完整原型如下：\n\n\tngx_int_t\n\tngx_open_cached_file(ngx_open_file_cache_t *cache, \n\t\tngx_str_t *name,\n\t\tngx_open_file_info_t *of, \n\t\tngx_pool_t *pool)\n\n其中的name参数比较有意思，在nginx中，ngx_str_t比u_char\\*多了一个长度字段。小心！这个函数内部并没有考虑name的长度，而是粗暴的调用了：\n\n\tfd = ngx_open_file(name->data, mode, create, access);\n\nngx_open_file()是对open()的简单封装，如下：\n\n\t#ifdef __CYGWIN__\n\t\t#define NGX_HAVE_CASELESS_FILESYSTEM  1\n\t\t#define ngx_open_file(name, mode, create, access)\\\n\t\t\topen((const char *) name, mode|create|O_BINARY, access)\n\t#else\n\t\t#define ngx_open_file(name, mode, create, access)\\\n\t\t\topen((const char *) name, mode|create, access)\n\t#endif\n\n所以，在调用这个函数打开文件时，除了要用ngx_str_t封装文件路径，还要注意这个路径一定要用\\0结尾。\n\n## tips\n1. SPS和PPS何时发送？\n\n\tIDR(nalu_type=5)之前发送\n\n2. PMT和PAT如何构造？\n\n\tPMT和PAT为固定字段，每GOP发送一次即可。\n\n3. 加入条带分割NAL头部对现有的H.264数据有何影响？\n\n\t目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)\n\n4. 码流和网络流形式的NAL在转换时需要注意哪些？\n\n\t一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01\n\n5. AAC头部是否需要修改？\n\n\tAAC需要使用ADST封装\n\n6. ADST包含哪些参数？从MP4文件的何box中读取参数？\n\n\tprofile: (object_type - 1)\n\n\tsampling frequency: sample_rate_index\n\t\n\tchannel configuration: channels\n\t\n\t通过mp4a->esds读取上述参数\n\n7. 音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？\n\n\t音频打包到一个PES再发送，大小为2930\n\n8. 生成m3u8时如何分割？\n\n\t以GOP为分割\n\n9. aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？\n\n\taac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024\n\n10. MP4中的elst atom应如何处理？\n\n\tpts -= elst_start_time\n","source":"_posts/2013-09-26-something-about-nginx-and-hls.md","raw":"---\nlayout: post\ntitle: \"Something About Nginx and HLS\"\ndescription: \"nginx作为hls服务器时需要考虑的问题\"\ncategory: \ntags: [nginx, HLS]\n---\n\n不涉及具体实现，只是总结一下近半个月来研究nginx和HLS以及综合两者时遇到的一些困难。\n\n## ngx_open_cached_file()\n\n完整原型如下：\n\n\tngx_int_t\n\tngx_open_cached_file(ngx_open_file_cache_t *cache, \n\t\tngx_str_t *name,\n\t\tngx_open_file_info_t *of, \n\t\tngx_pool_t *pool)\n\n其中的name参数比较有意思，在nginx中，ngx_str_t比u_char\\*多了一个长度字段。小心！这个函数内部并没有考虑name的长度，而是粗暴的调用了：\n\n\tfd = ngx_open_file(name->data, mode, create, access);\n\nngx_open_file()是对open()的简单封装，如下：\n\n\t#ifdef __CYGWIN__\n\t\t#define NGX_HAVE_CASELESS_FILESYSTEM  1\n\t\t#define ngx_open_file(name, mode, create, access)\\\n\t\t\topen((const char *) name, mode|create|O_BINARY, access)\n\t#else\n\t\t#define ngx_open_file(name, mode, create, access)\\\n\t\t\topen((const char *) name, mode|create, access)\n\t#endif\n\n所以，在调用这个函数打开文件时，除了要用ngx_str_t封装文件路径，还要注意这个路径一定要用\\0结尾。\n\n## tips\n1. SPS和PPS何时发送？\n\n\tIDR(nalu_type=5)之前发送\n\n2. PMT和PAT如何构造？\n\n\tPMT和PAT为固定字段，每GOP发送一次即可。\n\n3. 加入条带分割NAL头部对现有的H.264数据有何影响？\n\n\t目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)\n\n4. 码流和网络流形式的NAL在转换时需要注意哪些？\n\n\t一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01\n\n5. AAC头部是否需要修改？\n\n\tAAC需要使用ADST封装\n\n6. ADST包含哪些参数？从MP4文件的何box中读取参数？\n\n\tprofile: (object_type - 1)\n\n\tsampling frequency: sample_rate_index\n\t\n\tchannel configuration: channels\n\t\n\t通过mp4a->esds读取上述参数\n\n7. 音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？\n\n\t音频打包到一个PES再发送，大小为2930\n\n8. 生成m3u8时如何分割？\n\n\t以GOP为分割\n\n9. aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？\n\n\taac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024\n\n10. MP4中的elst atom应如何处理？\n\n\tpts -= elst_start_time\n","slug":"something-about-nginx-and-hls","published":1,"date":"2013-09-25T16:00:00.000Z","updated":"2018-03-07T06:11:13.303Z","comments":1,"photos":[],"link":"","_id":"cjegotuq70006i0foafkljozz","content":"<p>不涉及具体实现，只是总结一下近半个月来研究nginx和HLS以及综合两者时遇到的一些困难。</p>\n<h2 id=\"ngx-open-cached-file\"><a href=\"#ngx-open-cached-file\" class=\"headerlink\" title=\"ngx_open_cached_file()\"></a>ngx_open_cached_file()</h2><p>完整原型如下：</p>\n<pre><code>ngx_int_t\nngx_open_cached_file(ngx_open_file_cache_t *cache, \n    ngx_str_t *name,\n    ngx_open_file_info_t *of, \n    ngx_pool_t *pool)\n</code></pre><p>其中的name参数比较有意思，在nginx中，ngx_str_t比u_char*多了一个长度字段。小心！这个函数内部并没有考虑name的长度，而是粗暴的调用了：</p>\n<pre><code>fd = ngx_open_file(name-&gt;data, mode, create, access);\n</code></pre><p>ngx_open_file()是对open()的简单封装，如下：</p>\n<pre><code>#ifdef __CYGWIN__\n    #define NGX_HAVE_CASELESS_FILESYSTEM  1\n    #define ngx_open_file(name, mode, create, access)\\\n        open((const char *) name, mode|create|O_BINARY, access)\n#else\n    #define ngx_open_file(name, mode, create, access)\\\n        open((const char *) name, mode|create, access)\n#endif\n</code></pre><p>所以，在调用这个函数打开文件时，除了要用ngx_str_t封装文件路径，还要注意这个路径一定要用\\0结尾。</p>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><ol>\n<li><p>SPS和PPS何时发送？</p>\n<p> IDR(nalu_type=5)之前发送</p>\n</li>\n<li><p>PMT和PAT如何构造？</p>\n<p> PMT和PAT为固定字段，每GOP发送一次即可。</p>\n</li>\n<li><p>加入条带分割NAL头部对现有的H.264数据有何影响？</p>\n<p> 目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)</p>\n</li>\n<li><p>码流和网络流形式的NAL在转换时需要注意哪些？</p>\n<p> 一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01</p>\n</li>\n<li><p>AAC头部是否需要修改？</p>\n<p> AAC需要使用ADST封装</p>\n</li>\n<li><p>ADST包含哪些参数？从MP4文件的何box中读取参数？</p>\n<p> profile: (object_type - 1)</p>\n<p> sampling frequency: sample_rate_index</p>\n<p> channel configuration: channels</p>\n<p> 通过mp4a-&gt;esds读取上述参数</p>\n</li>\n<li><p>音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？</p>\n<p> 音频打包到一个PES再发送，大小为2930</p>\n</li>\n<li><p>生成m3u8时如何分割？</p>\n<p> 以GOP为分割</p>\n</li>\n<li><p>aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？</p>\n<p> aac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024</p>\n</li>\n<li><p>MP4中的elst atom应如何处理？</p>\n<p>pts -= elst_start_time</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>不涉及具体实现，只是总结一下近半个月来研究nginx和HLS以及综合两者时遇到的一些困难。</p>\n<h2 id=\"ngx-open-cached-file\"><a href=\"#ngx-open-cached-file\" class=\"headerlink\" title=\"ngx_open_cached_file()\"></a>ngx_open_cached_file()</h2><p>完整原型如下：</p>\n<pre><code>ngx_int_t\nngx_open_cached_file(ngx_open_file_cache_t *cache, \n    ngx_str_t *name,\n    ngx_open_file_info_t *of, \n    ngx_pool_t *pool)\n</code></pre><p>其中的name参数比较有意思，在nginx中，ngx_str_t比u_char*多了一个长度字段。小心！这个函数内部并没有考虑name的长度，而是粗暴的调用了：</p>\n<pre><code>fd = ngx_open_file(name-&gt;data, mode, create, access);\n</code></pre><p>ngx_open_file()是对open()的简单封装，如下：</p>\n<pre><code>#ifdef __CYGWIN__\n    #define NGX_HAVE_CASELESS_FILESYSTEM  1\n    #define ngx_open_file(name, mode, create, access)\\\n        open((const char *) name, mode|create|O_BINARY, access)\n#else\n    #define ngx_open_file(name, mode, create, access)\\\n        open((const char *) name, mode|create, access)\n#endif\n</code></pre><p>所以，在调用这个函数打开文件时，除了要用ngx_str_t封装文件路径，还要注意这个路径一定要用\\0结尾。</p>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><ol>\n<li><p>SPS和PPS何时发送？</p>\n<p> IDR(nalu_type=5)之前发送</p>\n</li>\n<li><p>PMT和PAT如何构造？</p>\n<p> PMT和PAT为固定字段，每GOP发送一次即可。</p>\n</li>\n<li><p>加入条带分割NAL头部对现有的H.264数据有何影响？</p>\n<p> 目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)</p>\n</li>\n<li><p>码流和网络流形式的NAL在转换时需要注意哪些？</p>\n<p> 一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01</p>\n</li>\n<li><p>AAC头部是否需要修改？</p>\n<p> AAC需要使用ADST封装</p>\n</li>\n<li><p>ADST包含哪些参数？从MP4文件的何box中读取参数？</p>\n<p> profile: (object_type - 1)</p>\n<p> sampling frequency: sample_rate_index</p>\n<p> channel configuration: channels</p>\n<p> 通过mp4a-&gt;esds读取上述参数</p>\n</li>\n<li><p>音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？</p>\n<p> 音频打包到一个PES再发送，大小为2930</p>\n</li>\n<li><p>生成m3u8时如何分割？</p>\n<p> 以GOP为分割</p>\n</li>\n<li><p>aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？</p>\n<p> aac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024</p>\n</li>\n<li><p>MP4中的elst atom应如何处理？</p>\n<p>pts -= elst_start_time</p>\n</li>\n</ol>\n"},{"layout":"post","title":"std::string::find和std::string::npos的使用备忘","description":"与size_t有关","category":null,"_content":"\n项目中需要手动解析路径，我的开发机是32位系统，运行无问题，但是部署到64位的生产环境时，解析出现了莫名其妙的错误。\n翻阅basic_string.h后发现了问题的原因，错误的将std::string:find的结果赋值给unsigned int。\n\n\tunsigned int begin; // 注意变量类型！\n\tstd::string test_str = \"helloworld\";\n\tif(std::string::npos != (begin = test_str.find(\"/\"))) // 赋值时出现了问题\n\t{…}\n\n改成如下的形式，问题解决。\n\n\tsize_t begin; // 注意变量类型！\n\tstd::string test_str = \"helloworld\";\n\tif(std::string::npos != (begin = test_str.find(\"/\"))) // 问题解决\n\t{…}\n\n根本原因是basic_string.h将npos定义为size_type的-1。\n","source":"_posts/2013-04-12-cpp_standard_library_string_find_and_npos_usage.md","raw":"---\nlayout: post\ntitle: \"std::string::find和std::string::npos的使用备忘\"\ndescription: \"与size_t有关\"\ncategory: \ntags: []\n---\n\n项目中需要手动解析路径，我的开发机是32位系统，运行无问题，但是部署到64位的生产环境时，解析出现了莫名其妙的错误。\n翻阅basic_string.h后发现了问题的原因，错误的将std::string:find的结果赋值给unsigned int。\n\n\tunsigned int begin; // 注意变量类型！\n\tstd::string test_str = \"helloworld\";\n\tif(std::string::npos != (begin = test_str.find(\"/\"))) // 赋值时出现了问题\n\t{…}\n\n改成如下的形式，问题解决。\n\n\tsize_t begin; // 注意变量类型！\n\tstd::string test_str = \"helloworld\";\n\tif(std::string::npos != (begin = test_str.find(\"/\"))) // 问题解决\n\t{…}\n\n根本原因是basic_string.h将npos定义为size_type的-1。\n","slug":"cpp_standard_library_string_find_and_npos_usage","published":1,"date":"2013-04-11T16:00:00.000Z","updated":"2018-03-07T06:11:13.298Z","comments":1,"photos":[],"link":"","_id":"cjegotuq90007i0foub7v3a2l","content":"<p>项目中需要手动解析路径，我的开发机是32位系统，运行无问题，但是部署到64位的生产环境时，解析出现了莫名其妙的错误。<br>翻阅basic_string.h后发现了问题的原因，错误的将std::string:find的结果赋值给unsigned int。</p>\n<pre><code>unsigned int begin; // 注意变量类型！\nstd::string test_str = &quot;helloworld&quot;;\nif(std::string::npos != (begin = test_str.find(&quot;/&quot;))) // 赋值时出现了问题\n{…}\n</code></pre><p>改成如下的形式，问题解决。</p>\n<pre><code>size_t begin; // 注意变量类型！\nstd::string test_str = &quot;helloworld&quot;;\nif(std::string::npos != (begin = test_str.find(&quot;/&quot;))) // 问题解决\n{…}\n</code></pre><p>根本原因是basic_string.h将npos定义为size_type的-1。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目中需要手动解析路径，我的开发机是32位系统，运行无问题，但是部署到64位的生产环境时，解析出现了莫名其妙的错误。<br>翻阅basic_string.h后发现了问题的原因，错误的将std::string:find的结果赋值给unsigned int。</p>\n<pre><code>unsigned int begin; // 注意变量类型！\nstd::string test_str = &quot;helloworld&quot;;\nif(std::string::npos != (begin = test_str.find(&quot;/&quot;))) // 赋值时出现了问题\n{…}\n</code></pre><p>改成如下的形式，问题解决。</p>\n<pre><code>size_t begin; // 注意变量类型！\nstd::string test_str = &quot;helloworld&quot;;\nif(std::string::npos != (begin = test_str.find(&quot;/&quot;))) // 问题解决\n{…}\n</code></pre><p>根本原因是basic_string.h将npos定义为size_type的-1。</p>\n"},{"layout":"post","title":"nginx-rtmp-module summary","description":"总结一些在阅读代码和使用中遇到的问题","category":null,"_content":"\n##项目主页:\n[https://github.com/arut/nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module)\n\n##项目介绍：\nnginx-rtmp-module是为nginx开发的一组模块，实现基于nginx的流媒体服务器，包括流发布，转发，录制等功能。具体参考项目主页及项目wiki。\n\n注意，该项目正在开发中，某些功能尚不稳定，代码结构也可能在将来发生较大的变化。\n\n##总结\n###配置解析\n配置解析要从rtmp命令开始，这是一个顶级命令，和http、events等平级。通过阅读代码能看出来，该命令的解析参考了http的解析流程，具体代码位于nginx_rtmp.c中，如果以前对http命令解析过程有了解，相信这里也能很快理解。\n\nnginx-rtmp-module项目实现的是一组模块，这里为了描述方便，仅用短命名表示各模块，比如core模块，hls模块等，需要注意的是nginx_rtmp.c中声明的模块，这里称呼他为根模块。\n\n这是一份常见也很典型的rtmp模块配置：\n\t\n\trtmp {\n\t    server {\n\n\t        listen 1935; # 监听1935端口\n\t\n\t        application live {\n\t            live on; # 启用直播   \n\t\n\t            hls on;  # 启用HLS\n\t            hls_path /tmp/tv26; # HLS缓存路径\n\t            \n\t            recorder record_tv26{ # 启用录制\n\t                record all; # 收录音视频\n\t                record_path /tmp/rec; # 收录路径\n\t            }   \n\t        }   \n\t    }   \n    \n具体解析部分如下：\n    \n\t/* rtmp{}块解析函数，一切与rtmp有关的配置解析从这里开始 */\n\tstatic char *\n\tngx_rtmp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n\t{\n\t    char                        *rv;\n\t    ngx_uint_t                   i, m, mi, s;\n\t    ngx_conf_t                   pcf;\n\t    ngx_array_t                  ports;\n\t    ngx_rtmp_listen_t           *listen;\n\t    ngx_rtmp_module_t           *module;\n\t    ngx_rtmp_conf_ctx_t         *ctx;\n\t    ngx_rtmp_core_srv_conf_t    *cscf, **cscfp;\n\t    ngx_rtmp_core_main_conf_t   *cmcf;\n\t\n\t\t/* \n\t\ttypedef struct {\n\t\t    void                  **main_conf;\n\t\t    void                  **srv_conf;\n\t\t    void                  **app_conf;\n\t\t} ngx_rtmp_conf_ctx_t;\n\t\t * 这个结构体再配置解析过程中见到非常多，server命令和application命令解析时也会创建一个这样的结构体，需要注意的时，这个结构体中main_conf是一次rtmp{}块解析过程中唯一的，其他命令解析到的配置将直接修改该main_conf，与另两个结构体不同。\n\t\t */\n\t    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_conf_ctx_t));\n\t    if (ctx == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    *(ngx_rtmp_conf_ctx_t **) conf = ctx;\n\t\n\t    /* count the number of the rtmp modules and set up their indices */\n\t    /* 计算RTMP模块总数，并为模块编号 */\n\t\n\t    ngx_rtmp_max_module = 0;\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        ngx_modules[m]->ctx_index = ngx_rtmp_max_module++;\n\t    }\n\t\n\t\n\t    /* the rtmp main_conf context, it is the same in the all rtmp contexts */\n\t    /* 再次强调，创建main_conf上下文变量，全局唯一 */\n\t    ctx->main_conf = ngx_pcalloc(cf->pool,\n\t                                 sizeof(void *) * ngx_rtmp_max_module);// 这里使用了max创建数组\n\t    if (ctx->main_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t\n\t    /*\n\t     * the rtmp null srv_conf context, it is used to merge\n\t     * the server{}s' srv_conf's\n\t     * 创建srv_conf上下文变量\n\t     */\n\t\n\t    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n\t    if (ctx->srv_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t\n\t    /*\n\t     * the rtmp null app_conf context, it is used to merge\n\t     * the server{}s' app_conf's\n\t     * 创建app_conf上下文变量\n\t     */\n\t\n\t    ctx->app_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n\t    if (ctx->app_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t\n\t    /*\n\t     * create the main_conf's, the null srv_conf's, and the null app_conf's\n\t     * of the all rtmp modules\n\t     */\n\t    /* 遍历所有的RTMP模块，保证所有模块对应的conf不为空 */\n\t\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t        mi = ngx_modules[m]->ctx_index;\n\t\n\t        // 分别调用各模块的:\n\t        // create_main_conf，\n\t        // create_srv_conf\n\t        // create_app_conf\n\t        if (module->create_main_conf) {\n\t            ctx->main_conf[mi] = module->create_main_conf(cf);\n\t            if (ctx->main_conf[mi] == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t\n\t        if (module->create_srv_conf) {\n\t            ctx->srv_conf[mi] = module->create_srv_conf(cf);\n\t            if (ctx->srv_conf[mi] == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t\n\t        if (module->create_app_conf) {\n\t            ctx->app_conf[mi] = module->create_app_conf(cf);\n\t            if (ctx->app_conf[mi] == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t    }\n\t\n\t    // 备份ngx_conf_t，在rtmp{}块解析完成后恢复\n\t    pcf = *cf;\n\t    cf->ctx = ctx;\n\t\n\t    // 调用各RTMP模块的preconfiguration\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t\n\t        if (module->preconfiguration) {\n\t            if (module->preconfiguration(cf) != NGX_OK) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t    }\n\t\n\t    /* parse inside the rtmp{} block */\n\t    /* 进入rtmp{}块中继续解析配置，仅解析cmd_type=NGX_RTMP_MAIN_CONF的指令，比如server{}块。\n\t     * 这里要回顾一下ngx_rtmp_conf_ctx_t结构体，因为接下来的解析过程，实际上就是填充这三个结构体的过程。\n\t     * 结构体包括三个数组，分别是main_conf，srv_conf和app_conf，\n\t     * main_conf实际上一个ngx_rtmp_*_main_conf_t的数组，其中最重要的可能就是core模块的结构，\n\t      \n\t\t\ttypedef struct {\n\t\t\t\tngx_array_t             servers;    // ngx_rtmp_core_srv_conf_t \n\t\t\t\tngx_array_t             listen;     // ngx_rtmp_listen_t \n\t\t\t\t\n\t\t\t\tngx_array_t             events[NGX_RTMP_MAX_EVENT];\n\t\t\t\t\n\t\t\t\tngx_hash_t              amf_hash;\n\t\t\t\tngx_array_t             amf_arrays;\n\t\t\t\tngx_array_t             amf;\n\t\t\t} ngx_rtmp_core_main_conf_t;\n\t     \n\t     * 解析到的server{}块配置会保存到core模块的servers数组中\n\t     * 同样的，srv_conf是一个ngx_rtmp_*_srv_main_t的数组，其中最重要的是core模块中针对server配置的结构体，\n\t     \n\t\t\ttypedef struct ngx_rtmp_core_srv_conf_s {\n\t\t\t\tngx_array_t             applications; // ngx_rtmp_core_app_conf_t\n\t\t\t\t...\t\t\t\n\t\t\t\tngx_rtmp_conf_ctx_t    *ctx;\n\t\t\t} ngx_rtmp_core_srv_conf_t;\n\t     \n\t     * 解析到的application{}块会保存到相应server块的applications数组中 */\n\t\n\t    cf->module_type = NGX_RTMP_MODULE;\n\t    cf->cmd_type = NGX_RTMP_MAIN_CONF;\n\t    rv = ngx_conf_parse(cf, NULL);\n\t\n\t    if (rv != NGX_CONF_OK) {\n\t        *cf = pcf;\n\t        return rv;\n\t    }\n\t\n\t\n\t    /* init rtmp{} main_conf's, merge the server{}s' srv_conf's */\n\t\n\t    // cmcf => core module conf\n\t    cmcf = ctx->main_conf[ngx_rtmp_core_module.ctx_index];\n\t    cscfp = cmcf->servers.elts;\n\t\n\t    /* 合并各RTMP模块配置 \n\t     * 这里的合并有一点需要注意的是，core模块的配置必须首先被合并，这个通过写config文件来实现，只有这样，才能保证上一轮解析中的配置全部合并到ctx的三大数组中。\n\t     * 跟模块不在这一轮合并中出现，因为根模块的类型不是NGX_RTMP_MODULE而是NGX_CORE_MODULE\n\t     */\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t        // mi => module_index\n\t        mi = ngx_modules[m]->ctx_index;\n\t\n\t        /* init rtmp{} main_conf's */\n\t        /* 调用各main模块的init_main_conf */\n\t\n\t        cf->ctx = ctx;\n\t\n\t        // 调用各RTMP main模块的init_main_conf，因为全局统一使用一个main_conf数组，因此这里不需要“merge”\n\t        if (module->init_main_conf) {\n\t            rv = module->init_main_conf(cf, ctx->main_conf[mi]);\n\t            if (rv != NGX_CONF_OK) {\n\t                *cf = pcf;\n\t                return rv;\n\t            }\n\t        }\n\t\n\t        /* 分别调用各模块merge_srv_conf和merge_app_conf，如果需要的话\n\t         * ngx_parse_conf产生的servers用在这里*/\n\t        for (s = 0; s < cmcf->servers.nelts; s++) {\n\t\n\t            /* merge the server{}s' srv_conf's */\n\t\n\t            cf->ctx = cscfp[s]->ctx;\n\t\n\t            if (module->merge_srv_conf) {\n\t                rv = module->merge_srv_conf(cf,\n\t                                            ctx->srv_conf[mi],\n\t                                            cscfp[s]->ctx->srv_conf[mi]);\n\t                if (rv != NGX_CONF_OK) {\n\t                    *cf = pcf;\n\t                    return rv;\n\t                }\n\t            }\n\t\n\t            if (module->merge_app_conf) {\n\t\n\t                /* merge the server{}'s app_conf */\n\t\n\t                /*ctx->app_conf = cscfp[s]->ctx->loc_conf;*/\n\t\n\t                rv = module->merge_app_conf(cf, \n\t                                            ctx->app_conf[mi],\n\t                                            cscfp[s]->ctx->app_conf[mi]);\n\t                if (rv != NGX_CONF_OK) {\n\t                    *cf = pcf;\n\t                    return rv;\n\t                }\n\t\n\t                /* merge the applications{}' app_conf's \n\t                 * 解析applications数组\n\t                 * cscfp = core server conf pointer*/\n\t\n\t                cscf = cscfp[s]->ctx->srv_conf[ngx_rtmp_core_module.ctx_index];\n\t\n\t                /* 递归的解析applications数组，因为application有可能有子块，比如recorder{}块 */\n\t                rv = ngx_rtmp_merge_applications(cf, &cscf->applications,\n\t                                            cscfp[s]->ctx->app_conf,\n\t                                            module, mi);\n\t                if (rv != NGX_CONF_OK) {\n\t                    *cf = pcf;\n\t                    return rv;\n\t                }\n\t            }\n\t\n\t        }\n\t    }\n\t\n\t\n\t    /* 初始化events数组和amf数组 */\n\t    if (ngx_rtmp_init_events(cf, cmcf) != NGX_OK) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    /* 调用各RTMP模块的postconfiguration */\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t\n\t        if (module->postconfiguration) {\n\t            if (module->postconfiguration(cf) != NGX_OK) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t    }\n\t\n\t    // 恢复conf\n\t    *cf = pcf;\n\t\n\t    /* 初始化RTMP各事件响应函数，AMF各事件响应函数及hash表 */\n\t    if (ngx_rtmp_init_event_handlers(cf, cmcf) != NGX_OK) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    /* 初始化端口数组 */\n\t    if (ngx_array_init(&ports, cf->temp_pool, 4, sizeof(ngx_rtmp_conf_port_t))\n\t        != NGX_OK)\n\t    {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    listen = cmcf->listen.elts;\n\t\n\t    // 添加listen地址到port数组\n\t    for (i = 0; i < cmcf->listen.nelts; i++) {\n\t        if (ngx_rtmp_add_ports(cf, &ports, &listen[i]) != NGX_OK) {\n\t            return NGX_CONF_ERROR;\n\t        }\n\t    }\n\t\n\t    /* 将port中的监听地址添加到nginx的监听列表 */\n\t    return ngx_rtmp_optimize_servers(cf, &ports);\n\t}\n仅看根模块的rtmp{}块解析还无法全面了解配置解析过程，下面贴出另一个重要模块，core模块，的server{}块和applicaiton{}块解析过程，他们在ngx_rtmp_core_module.c中。\n\n\tstatic char *\n\tngx_rtmp_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf/*srv_conf*/)\n\t{\n\t    char                       *rv;\n\t    void                       *mconf;\n\t    ngx_uint_t                  m;\n\t    ngx_conf_t                  pcf;\n\t    ngx_rtmp_module_t          *module;\n\t    ngx_rtmp_conf_ctx_t        *ctx, *rtmp_ctx;\n\t    ngx_rtmp_core_srv_conf_t   *cscf, **cscfp;\n\t    ngx_rtmp_core_main_conf_t  *cmcf;\n\t\n\t    // 每解析到一个server就创建一个新的conf_ctx\n\t    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_conf_ctx_t));\n\t    if (ctx == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    rtmp_ctx = cf->ctx;\n\t    // 使用rtmp级conf_ctx的main_conf覆盖新建的本server的main_conf，以保证唯一的main_conf数组\n\t    ctx->main_conf = rtmp_ctx->main_conf;\n\t\n\t    /* the server{}'s srv_conf */\n\t    /* 为srv_conf和app_conf申请内存 */\n\t\n\t    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n\t    if (ctx->srv_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    ctx->app_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n\t    if (ctx->app_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    // 初始化srv_conf和app_conf\n\t    // 调用各RTMP模块的create_srv_conf和create_app_conf\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t\n\t        if (module->create_srv_conf) {\n\t            mconf = module->create_srv_conf(cf);\n\t            if (mconf == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t\n\t            ctx->srv_conf[ngx_modules[m]->ctx_index] = mconf;\n\t        }\n\t\n\t        if (module->create_app_conf) {\n\t            mconf = module->create_app_conf(cf);\n\t            if (mconf == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t\n\t            ctx->app_conf[ngx_modules[m]->ctx_index] = mconf;\n\t        }\n\t    }\n\t\n\t    /* the server configuration context */\n\t    /* 将新申请的conf_ctx放入main_conf的servers数组\n\t     * servers数组是ngx_rtmp_core_srv_conf_t的集合*/\n\t    cscf = ctx->srv_conf[ngx_rtmp_core_module.ctx_index];\n\t    cscf->ctx = ctx; // 自我链接，用于下一步放入servers\n\t    /* 至此，解析server{}块配置的过程实际上就结束了，需要合并配置时，main_conf[core_module]->servers[...]->ctx->srv_conf[core_module]即可找到每一server{}块的配置，\n\t     * application{}块的解析也同样如此，不同的时application块中也有applications[]数组，因此需要递归的合并子模块的配置\n\t     */\n\t\n\t    cmcf = ctx->main_conf[ngx_rtmp_core_module.ctx_index];\n\t\n\t    cscfp = ngx_array_push(&cmcf->servers);/* 由于main_conf是直接覆盖而非另外生成，因此这里放入的servers数组就是输入的main_conf */\n\t    if (cscfp == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    *cscfp = cscf;\n\t\n\t    /* parse inside server{} \n\t     * 进入server{}块内部继续解析，这里仅解析NGX_RTMP_SRV_CONF类型的命令，包括listen和application等命令。\n\t    */\n\t\n\t    pcf = *cf;\n\t    cf->ctx = ctx;\n\t    cf->cmd_type = NGX_RTMP_SRV_CONF;\n\t\n\t    rv = ngx_conf_parse(cf, NULL);\n\t\n\t    *cf = pcf;\n\t\n\t    return rv;\n\t}\n\n### TODO 接受PUSH RTMP流：\n\n\n##参考：\nNginx模块开发入门 [http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html](http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html)\n\nEmiller's Guide To Nginx Module Development [http://www.evanmiller.org/nginx-modules-guide.html](http://www.evanmiller.org/nginx-modules-guide.html)\n","source":"_posts/2013-07-23-nginx-rtmp-module-summary.md","raw":"---\nlayout: post\ntitle: \"nginx-rtmp-module summary\"\ndescription: \"总结一些在阅读代码和使用中遇到的问题\"\ncategory: \ntags: [nginx, rtmp]\n---\n\n##项目主页:\n[https://github.com/arut/nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module)\n\n##项目介绍：\nnginx-rtmp-module是为nginx开发的一组模块，实现基于nginx的流媒体服务器，包括流发布，转发，录制等功能。具体参考项目主页及项目wiki。\n\n注意，该项目正在开发中，某些功能尚不稳定，代码结构也可能在将来发生较大的变化。\n\n##总结\n###配置解析\n配置解析要从rtmp命令开始，这是一个顶级命令，和http、events等平级。通过阅读代码能看出来，该命令的解析参考了http的解析流程，具体代码位于nginx_rtmp.c中，如果以前对http命令解析过程有了解，相信这里也能很快理解。\n\nnginx-rtmp-module项目实现的是一组模块，这里为了描述方便，仅用短命名表示各模块，比如core模块，hls模块等，需要注意的是nginx_rtmp.c中声明的模块，这里称呼他为根模块。\n\n这是一份常见也很典型的rtmp模块配置：\n\t\n\trtmp {\n\t    server {\n\n\t        listen 1935; # 监听1935端口\n\t\n\t        application live {\n\t            live on; # 启用直播   \n\t\n\t            hls on;  # 启用HLS\n\t            hls_path /tmp/tv26; # HLS缓存路径\n\t            \n\t            recorder record_tv26{ # 启用录制\n\t                record all; # 收录音视频\n\t                record_path /tmp/rec; # 收录路径\n\t            }   \n\t        }   \n\t    }   \n    \n具体解析部分如下：\n    \n\t/* rtmp{}块解析函数，一切与rtmp有关的配置解析从这里开始 */\n\tstatic char *\n\tngx_rtmp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n\t{\n\t    char                        *rv;\n\t    ngx_uint_t                   i, m, mi, s;\n\t    ngx_conf_t                   pcf;\n\t    ngx_array_t                  ports;\n\t    ngx_rtmp_listen_t           *listen;\n\t    ngx_rtmp_module_t           *module;\n\t    ngx_rtmp_conf_ctx_t         *ctx;\n\t    ngx_rtmp_core_srv_conf_t    *cscf, **cscfp;\n\t    ngx_rtmp_core_main_conf_t   *cmcf;\n\t\n\t\t/* \n\t\ttypedef struct {\n\t\t    void                  **main_conf;\n\t\t    void                  **srv_conf;\n\t\t    void                  **app_conf;\n\t\t} ngx_rtmp_conf_ctx_t;\n\t\t * 这个结构体再配置解析过程中见到非常多，server命令和application命令解析时也会创建一个这样的结构体，需要注意的时，这个结构体中main_conf是一次rtmp{}块解析过程中唯一的，其他命令解析到的配置将直接修改该main_conf，与另两个结构体不同。\n\t\t */\n\t    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_conf_ctx_t));\n\t    if (ctx == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    *(ngx_rtmp_conf_ctx_t **) conf = ctx;\n\t\n\t    /* count the number of the rtmp modules and set up their indices */\n\t    /* 计算RTMP模块总数，并为模块编号 */\n\t\n\t    ngx_rtmp_max_module = 0;\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        ngx_modules[m]->ctx_index = ngx_rtmp_max_module++;\n\t    }\n\t\n\t\n\t    /* the rtmp main_conf context, it is the same in the all rtmp contexts */\n\t    /* 再次强调，创建main_conf上下文变量，全局唯一 */\n\t    ctx->main_conf = ngx_pcalloc(cf->pool,\n\t                                 sizeof(void *) * ngx_rtmp_max_module);// 这里使用了max创建数组\n\t    if (ctx->main_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t\n\t    /*\n\t     * the rtmp null srv_conf context, it is used to merge\n\t     * the server{}s' srv_conf's\n\t     * 创建srv_conf上下文变量\n\t     */\n\t\n\t    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n\t    if (ctx->srv_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t\n\t    /*\n\t     * the rtmp null app_conf context, it is used to merge\n\t     * the server{}s' app_conf's\n\t     * 创建app_conf上下文变量\n\t     */\n\t\n\t    ctx->app_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n\t    if (ctx->app_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t\n\t    /*\n\t     * create the main_conf's, the null srv_conf's, and the null app_conf's\n\t     * of the all rtmp modules\n\t     */\n\t    /* 遍历所有的RTMP模块，保证所有模块对应的conf不为空 */\n\t\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t        mi = ngx_modules[m]->ctx_index;\n\t\n\t        // 分别调用各模块的:\n\t        // create_main_conf，\n\t        // create_srv_conf\n\t        // create_app_conf\n\t        if (module->create_main_conf) {\n\t            ctx->main_conf[mi] = module->create_main_conf(cf);\n\t            if (ctx->main_conf[mi] == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t\n\t        if (module->create_srv_conf) {\n\t            ctx->srv_conf[mi] = module->create_srv_conf(cf);\n\t            if (ctx->srv_conf[mi] == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t\n\t        if (module->create_app_conf) {\n\t            ctx->app_conf[mi] = module->create_app_conf(cf);\n\t            if (ctx->app_conf[mi] == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t    }\n\t\n\t    // 备份ngx_conf_t，在rtmp{}块解析完成后恢复\n\t    pcf = *cf;\n\t    cf->ctx = ctx;\n\t\n\t    // 调用各RTMP模块的preconfiguration\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t\n\t        if (module->preconfiguration) {\n\t            if (module->preconfiguration(cf) != NGX_OK) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t    }\n\t\n\t    /* parse inside the rtmp{} block */\n\t    /* 进入rtmp{}块中继续解析配置，仅解析cmd_type=NGX_RTMP_MAIN_CONF的指令，比如server{}块。\n\t     * 这里要回顾一下ngx_rtmp_conf_ctx_t结构体，因为接下来的解析过程，实际上就是填充这三个结构体的过程。\n\t     * 结构体包括三个数组，分别是main_conf，srv_conf和app_conf，\n\t     * main_conf实际上一个ngx_rtmp_*_main_conf_t的数组，其中最重要的可能就是core模块的结构，\n\t      \n\t\t\ttypedef struct {\n\t\t\t\tngx_array_t             servers;    // ngx_rtmp_core_srv_conf_t \n\t\t\t\tngx_array_t             listen;     // ngx_rtmp_listen_t \n\t\t\t\t\n\t\t\t\tngx_array_t             events[NGX_RTMP_MAX_EVENT];\n\t\t\t\t\n\t\t\t\tngx_hash_t              amf_hash;\n\t\t\t\tngx_array_t             amf_arrays;\n\t\t\t\tngx_array_t             amf;\n\t\t\t} ngx_rtmp_core_main_conf_t;\n\t     \n\t     * 解析到的server{}块配置会保存到core模块的servers数组中\n\t     * 同样的，srv_conf是一个ngx_rtmp_*_srv_main_t的数组，其中最重要的是core模块中针对server配置的结构体，\n\t     \n\t\t\ttypedef struct ngx_rtmp_core_srv_conf_s {\n\t\t\t\tngx_array_t             applications; // ngx_rtmp_core_app_conf_t\n\t\t\t\t...\t\t\t\n\t\t\t\tngx_rtmp_conf_ctx_t    *ctx;\n\t\t\t} ngx_rtmp_core_srv_conf_t;\n\t     \n\t     * 解析到的application{}块会保存到相应server块的applications数组中 */\n\t\n\t    cf->module_type = NGX_RTMP_MODULE;\n\t    cf->cmd_type = NGX_RTMP_MAIN_CONF;\n\t    rv = ngx_conf_parse(cf, NULL);\n\t\n\t    if (rv != NGX_CONF_OK) {\n\t        *cf = pcf;\n\t        return rv;\n\t    }\n\t\n\t\n\t    /* init rtmp{} main_conf's, merge the server{}s' srv_conf's */\n\t\n\t    // cmcf => core module conf\n\t    cmcf = ctx->main_conf[ngx_rtmp_core_module.ctx_index];\n\t    cscfp = cmcf->servers.elts;\n\t\n\t    /* 合并各RTMP模块配置 \n\t     * 这里的合并有一点需要注意的是，core模块的配置必须首先被合并，这个通过写config文件来实现，只有这样，才能保证上一轮解析中的配置全部合并到ctx的三大数组中。\n\t     * 跟模块不在这一轮合并中出现，因为根模块的类型不是NGX_RTMP_MODULE而是NGX_CORE_MODULE\n\t     */\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t        // mi => module_index\n\t        mi = ngx_modules[m]->ctx_index;\n\t\n\t        /* init rtmp{} main_conf's */\n\t        /* 调用各main模块的init_main_conf */\n\t\n\t        cf->ctx = ctx;\n\t\n\t        // 调用各RTMP main模块的init_main_conf，因为全局统一使用一个main_conf数组，因此这里不需要“merge”\n\t        if (module->init_main_conf) {\n\t            rv = module->init_main_conf(cf, ctx->main_conf[mi]);\n\t            if (rv != NGX_CONF_OK) {\n\t                *cf = pcf;\n\t                return rv;\n\t            }\n\t        }\n\t\n\t        /* 分别调用各模块merge_srv_conf和merge_app_conf，如果需要的话\n\t         * ngx_parse_conf产生的servers用在这里*/\n\t        for (s = 0; s < cmcf->servers.nelts; s++) {\n\t\n\t            /* merge the server{}s' srv_conf's */\n\t\n\t            cf->ctx = cscfp[s]->ctx;\n\t\n\t            if (module->merge_srv_conf) {\n\t                rv = module->merge_srv_conf(cf,\n\t                                            ctx->srv_conf[mi],\n\t                                            cscfp[s]->ctx->srv_conf[mi]);\n\t                if (rv != NGX_CONF_OK) {\n\t                    *cf = pcf;\n\t                    return rv;\n\t                }\n\t            }\n\t\n\t            if (module->merge_app_conf) {\n\t\n\t                /* merge the server{}'s app_conf */\n\t\n\t                /*ctx->app_conf = cscfp[s]->ctx->loc_conf;*/\n\t\n\t                rv = module->merge_app_conf(cf, \n\t                                            ctx->app_conf[mi],\n\t                                            cscfp[s]->ctx->app_conf[mi]);\n\t                if (rv != NGX_CONF_OK) {\n\t                    *cf = pcf;\n\t                    return rv;\n\t                }\n\t\n\t                /* merge the applications{}' app_conf's \n\t                 * 解析applications数组\n\t                 * cscfp = core server conf pointer*/\n\t\n\t                cscf = cscfp[s]->ctx->srv_conf[ngx_rtmp_core_module.ctx_index];\n\t\n\t                /* 递归的解析applications数组，因为application有可能有子块，比如recorder{}块 */\n\t                rv = ngx_rtmp_merge_applications(cf, &cscf->applications,\n\t                                            cscfp[s]->ctx->app_conf,\n\t                                            module, mi);\n\t                if (rv != NGX_CONF_OK) {\n\t                    *cf = pcf;\n\t                    return rv;\n\t                }\n\t            }\n\t\n\t        }\n\t    }\n\t\n\t\n\t    /* 初始化events数组和amf数组 */\n\t    if (ngx_rtmp_init_events(cf, cmcf) != NGX_OK) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    /* 调用各RTMP模块的postconfiguration */\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t\n\t        if (module->postconfiguration) {\n\t            if (module->postconfiguration(cf) != NGX_OK) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t        }\n\t    }\n\t\n\t    // 恢复conf\n\t    *cf = pcf;\n\t\n\t    /* 初始化RTMP各事件响应函数，AMF各事件响应函数及hash表 */\n\t    if (ngx_rtmp_init_event_handlers(cf, cmcf) != NGX_OK) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    /* 初始化端口数组 */\n\t    if (ngx_array_init(&ports, cf->temp_pool, 4, sizeof(ngx_rtmp_conf_port_t))\n\t        != NGX_OK)\n\t    {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    listen = cmcf->listen.elts;\n\t\n\t    // 添加listen地址到port数组\n\t    for (i = 0; i < cmcf->listen.nelts; i++) {\n\t        if (ngx_rtmp_add_ports(cf, &ports, &listen[i]) != NGX_OK) {\n\t            return NGX_CONF_ERROR;\n\t        }\n\t    }\n\t\n\t    /* 将port中的监听地址添加到nginx的监听列表 */\n\t    return ngx_rtmp_optimize_servers(cf, &ports);\n\t}\n仅看根模块的rtmp{}块解析还无法全面了解配置解析过程，下面贴出另一个重要模块，core模块，的server{}块和applicaiton{}块解析过程，他们在ngx_rtmp_core_module.c中。\n\n\tstatic char *\n\tngx_rtmp_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf/*srv_conf*/)\n\t{\n\t    char                       *rv;\n\t    void                       *mconf;\n\t    ngx_uint_t                  m;\n\t    ngx_conf_t                  pcf;\n\t    ngx_rtmp_module_t          *module;\n\t    ngx_rtmp_conf_ctx_t        *ctx, *rtmp_ctx;\n\t    ngx_rtmp_core_srv_conf_t   *cscf, **cscfp;\n\t    ngx_rtmp_core_main_conf_t  *cmcf;\n\t\n\t    // 每解析到一个server就创建一个新的conf_ctx\n\t    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_conf_ctx_t));\n\t    if (ctx == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    rtmp_ctx = cf->ctx;\n\t    // 使用rtmp级conf_ctx的main_conf覆盖新建的本server的main_conf，以保证唯一的main_conf数组\n\t    ctx->main_conf = rtmp_ctx->main_conf;\n\t\n\t    /* the server{}'s srv_conf */\n\t    /* 为srv_conf和app_conf申请内存 */\n\t\n\t    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n\t    if (ctx->srv_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    ctx->app_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n\t    if (ctx->app_conf == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    // 初始化srv_conf和app_conf\n\t    // 调用各RTMP模块的create_srv_conf和create_app_conf\n\t    for (m = 0; ngx_modules[m]; m++) {\n\t        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n\t            continue;\n\t        }\n\t\n\t        module = ngx_modules[m]->ctx;\n\t\n\t        if (module->create_srv_conf) {\n\t            mconf = module->create_srv_conf(cf);\n\t            if (mconf == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t\n\t            ctx->srv_conf[ngx_modules[m]->ctx_index] = mconf;\n\t        }\n\t\n\t        if (module->create_app_conf) {\n\t            mconf = module->create_app_conf(cf);\n\t            if (mconf == NULL) {\n\t                return NGX_CONF_ERROR;\n\t            }\n\t\n\t            ctx->app_conf[ngx_modules[m]->ctx_index] = mconf;\n\t        }\n\t    }\n\t\n\t    /* the server configuration context */\n\t    /* 将新申请的conf_ctx放入main_conf的servers数组\n\t     * servers数组是ngx_rtmp_core_srv_conf_t的集合*/\n\t    cscf = ctx->srv_conf[ngx_rtmp_core_module.ctx_index];\n\t    cscf->ctx = ctx; // 自我链接，用于下一步放入servers\n\t    /* 至此，解析server{}块配置的过程实际上就结束了，需要合并配置时，main_conf[core_module]->servers[...]->ctx->srv_conf[core_module]即可找到每一server{}块的配置，\n\t     * application{}块的解析也同样如此，不同的时application块中也有applications[]数组，因此需要递归的合并子模块的配置\n\t     */\n\t\n\t    cmcf = ctx->main_conf[ngx_rtmp_core_module.ctx_index];\n\t\n\t    cscfp = ngx_array_push(&cmcf->servers);/* 由于main_conf是直接覆盖而非另外生成，因此这里放入的servers数组就是输入的main_conf */\n\t    if (cscfp == NULL) {\n\t        return NGX_CONF_ERROR;\n\t    }\n\t\n\t    *cscfp = cscf;\n\t\n\t    /* parse inside server{} \n\t     * 进入server{}块内部继续解析，这里仅解析NGX_RTMP_SRV_CONF类型的命令，包括listen和application等命令。\n\t    */\n\t\n\t    pcf = *cf;\n\t    cf->ctx = ctx;\n\t    cf->cmd_type = NGX_RTMP_SRV_CONF;\n\t\n\t    rv = ngx_conf_parse(cf, NULL);\n\t\n\t    *cf = pcf;\n\t\n\t    return rv;\n\t}\n\n### TODO 接受PUSH RTMP流：\n\n\n##参考：\nNginx模块开发入门 [http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html](http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html)\n\nEmiller's Guide To Nginx Module Development [http://www.evanmiller.org/nginx-modules-guide.html](http://www.evanmiller.org/nginx-modules-guide.html)\n","slug":"nginx-rtmp-module-summary","published":1,"date":"2013-07-22T16:00:00.000Z","updated":"2018-03-07T06:11:13.301Z","comments":1,"photos":[],"link":"","_id":"cjegotuqc0009i0foos5kmdg3","content":"<p>##项目主页:<br><a href=\"https://github.com/arut/nginx-rtmp-module\" target=\"_blank\" rel=\"noopener\">https://github.com/arut/nginx-rtmp-module</a></p>\n<p>##项目介绍：<br>nginx-rtmp-module是为nginx开发的一组模块，实现基于nginx的流媒体服务器，包括流发布，转发，录制等功能。具体参考项目主页及项目wiki。</p>\n<p>注意，该项目正在开发中，某些功能尚不稳定，代码结构也可能在将来发生较大的变化。</p>\n<p>##总结</p>\n<p>###配置解析<br>配置解析要从rtmp命令开始，这是一个顶级命令，和http、events等平级。通过阅读代码能看出来，该命令的解析参考了http的解析流程，具体代码位于nginx_rtmp.c中，如果以前对http命令解析过程有了解，相信这里也能很快理解。</p>\n<p>nginx-rtmp-module项目实现的是一组模块，这里为了描述方便，仅用短命名表示各模块，比如core模块，hls模块等，需要注意的是nginx_rtmp.c中声明的模块，这里称呼他为根模块。</p>\n<p>这是一份常见也很典型的rtmp模块配置：</p>\n<pre><code>rtmp {\n    server {\n\n        listen 1935; # 监听1935端口\n\n        application live {\n            live on; # 启用直播   \n\n            hls on;  # 启用HLS\n            hls_path /tmp/tv26; # HLS缓存路径\n\n            recorder record_tv26{ # 启用录制\n                record all; # 收录音视频\n                record_path /tmp/rec; # 收录路径\n            }   \n        }   \n    }   \n</code></pre><p>具体解析部分如下：</p>\n<pre><code>/* rtmp{}块解析函数，一切与rtmp有关的配置解析从这里开始 */\nstatic char *\nngx_rtmp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                        *rv;\n    ngx_uint_t                   i, m, mi, s;\n    ngx_conf_t                   pcf;\n    ngx_array_t                  ports;\n    ngx_rtmp_listen_t           *listen;\n    ngx_rtmp_module_t           *module;\n    ngx_rtmp_conf_ctx_t         *ctx;\n    ngx_rtmp_core_srv_conf_t    *cscf, **cscfp;\n    ngx_rtmp_core_main_conf_t   *cmcf;\n\n    /* \n    typedef struct {\n        void                  **main_conf;\n        void                  **srv_conf;\n        void                  **app_conf;\n    } ngx_rtmp_conf_ctx_t;\n     * 这个结构体再配置解析过程中见到非常多，server命令和application命令解析时也会创建一个这样的结构体，需要注意的时，这个结构体中main_conf是一次rtmp{}块解析过程中唯一的，其他命令解析到的配置将直接修改该main_conf，与另两个结构体不同。\n     */\n    ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *(ngx_rtmp_conf_ctx_t **) conf = ctx;\n\n    /* count the number of the rtmp modules and set up their indices */\n    /* 计算RTMP模块总数，并为模块编号 */\n\n    ngx_rtmp_max_module = 0;\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        ngx_modules[m]-&gt;ctx_index = ngx_rtmp_max_module++;\n    }\n\n\n    /* the rtmp main_conf context, it is the same in the all rtmp contexts */\n    /* 再次强调，创建main_conf上下文变量，全局唯一 */\n    ctx-&gt;main_conf = ngx_pcalloc(cf-&gt;pool,\n                                 sizeof(void *) * ngx_rtmp_max_module);// 这里使用了max创建数组\n    if (ctx-&gt;main_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * the rtmp null srv_conf context, it is used to merge\n     * the server{}s&apos; srv_conf&apos;s\n     * 创建srv_conf上下文变量\n     */\n\n    ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx-&gt;srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * the rtmp null app_conf context, it is used to merge\n     * the server{}s&apos; app_conf&apos;s\n     * 创建app_conf上下文变量\n     */\n\n    ctx-&gt;app_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx-&gt;app_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * create the main_conf&apos;s, the null srv_conf&apos;s, and the null app_conf&apos;s\n     * of the all rtmp modules\n     */\n    /* 遍历所有的RTMP模块，保证所有模块对应的conf不为空 */\n\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n        mi = ngx_modules[m]-&gt;ctx_index;\n\n        // 分别调用各模块的:\n        // create_main_conf，\n        // create_srv_conf\n        // create_app_conf\n        if (module-&gt;create_main_conf) {\n            ctx-&gt;main_conf[mi] = module-&gt;create_main_conf(cf);\n            if (ctx-&gt;main_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module-&gt;create_srv_conf) {\n            ctx-&gt;srv_conf[mi] = module-&gt;create_srv_conf(cf);\n            if (ctx-&gt;srv_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module-&gt;create_app_conf) {\n            ctx-&gt;app_conf[mi] = module-&gt;create_app_conf(cf);\n            if (ctx-&gt;app_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    // 备份ngx_conf_t，在rtmp{}块解析完成后恢复\n    pcf = *cf;\n    cf-&gt;ctx = ctx;\n\n    // 调用各RTMP模块的preconfiguration\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n\n        if (module-&gt;preconfiguration) {\n            if (module-&gt;preconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    /* parse inside the rtmp{} block */\n    /* 进入rtmp{}块中继续解析配置，仅解析cmd_type=NGX_RTMP_MAIN_CONF的指令，比如server{}块。\n     * 这里要回顾一下ngx_rtmp_conf_ctx_t结构体，因为接下来的解析过程，实际上就是填充这三个结构体的过程。\n     * 结构体包括三个数组，分别是main_conf，srv_conf和app_conf，\n     * main_conf实际上一个ngx_rtmp_*_main_conf_t的数组，其中最重要的可能就是core模块的结构，\n\n        typedef struct {\n            ngx_array_t             servers;    // ngx_rtmp_core_srv_conf_t \n            ngx_array_t             listen;     // ngx_rtmp_listen_t \n\n            ngx_array_t             events[NGX_RTMP_MAX_EVENT];\n\n            ngx_hash_t              amf_hash;\n            ngx_array_t             amf_arrays;\n            ngx_array_t             amf;\n        } ngx_rtmp_core_main_conf_t;\n\n     * 解析到的server{}块配置会保存到core模块的servers数组中\n     * 同样的，srv_conf是一个ngx_rtmp_*_srv_main_t的数组，其中最重要的是core模块中针对server配置的结构体，\n\n        typedef struct ngx_rtmp_core_srv_conf_s {\n            ngx_array_t             applications; // ngx_rtmp_core_app_conf_t\n            ...            \n            ngx_rtmp_conf_ctx_t    *ctx;\n        } ngx_rtmp_core_srv_conf_t;\n\n     * 解析到的application{}块会保存到相应server块的applications数组中 */\n\n    cf-&gt;module_type = NGX_RTMP_MODULE;\n    cf-&gt;cmd_type = NGX_RTMP_MAIN_CONF;\n    rv = ngx_conf_parse(cf, NULL);\n\n    if (rv != NGX_CONF_OK) {\n        *cf = pcf;\n        return rv;\n    }\n\n\n    /* init rtmp{} main_conf&apos;s, merge the server{}s&apos; srv_conf&apos;s */\n\n    // cmcf =&gt; core module conf\n    cmcf = ctx-&gt;main_conf[ngx_rtmp_core_module.ctx_index];\n    cscfp = cmcf-&gt;servers.elts;\n\n    /* 合并各RTMP模块配置 \n     * 这里的合并有一点需要注意的是，core模块的配置必须首先被合并，这个通过写config文件来实现，只有这样，才能保证上一轮解析中的配置全部合并到ctx的三大数组中。\n     * 跟模块不在这一轮合并中出现，因为根模块的类型不是NGX_RTMP_MODULE而是NGX_CORE_MODULE\n     */\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n        // mi =&gt; module_index\n        mi = ngx_modules[m]-&gt;ctx_index;\n\n        /* init rtmp{} main_conf&apos;s */\n        /* 调用各main模块的init_main_conf */\n\n        cf-&gt;ctx = ctx;\n\n        // 调用各RTMP main模块的init_main_conf，因为全局统一使用一个main_conf数组，因此这里不需要“merge”\n        if (module-&gt;init_main_conf) {\n            rv = module-&gt;init_main_conf(cf, ctx-&gt;main_conf[mi]);\n            if (rv != NGX_CONF_OK) {\n                *cf = pcf;\n                return rv;\n            }\n        }\n\n        /* 分别调用各模块merge_srv_conf和merge_app_conf，如果需要的话\n         * ngx_parse_conf产生的servers用在这里*/\n        for (s = 0; s &lt; cmcf-&gt;servers.nelts; s++) {\n\n            /* merge the server{}s&apos; srv_conf&apos;s */\n\n            cf-&gt;ctx = cscfp[s]-&gt;ctx;\n\n            if (module-&gt;merge_srv_conf) {\n                rv = module-&gt;merge_srv_conf(cf,\n                                            ctx-&gt;srv_conf[mi],\n                                            cscfp[s]-&gt;ctx-&gt;srv_conf[mi]);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n            }\n\n            if (module-&gt;merge_app_conf) {\n\n                /* merge the server{}&apos;s app_conf */\n\n                /*ctx-&gt;app_conf = cscfp[s]-&gt;ctx-&gt;loc_conf;*/\n\n                rv = module-&gt;merge_app_conf(cf, \n                                            ctx-&gt;app_conf[mi],\n                                            cscfp[s]-&gt;ctx-&gt;app_conf[mi]);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n\n                /* merge the applications{}&apos; app_conf&apos;s \n                 * 解析applications数组\n                 * cscfp = core server conf pointer*/\n\n                cscf = cscfp[s]-&gt;ctx-&gt;srv_conf[ngx_rtmp_core_module.ctx_index];\n\n                /* 递归的解析applications数组，因为application有可能有子块，比如recorder{}块 */\n                rv = ngx_rtmp_merge_applications(cf, &amp;cscf-&gt;applications,\n                                            cscfp[s]-&gt;ctx-&gt;app_conf,\n                                            module, mi);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n            }\n\n        }\n    }\n\n\n    /* 初始化events数组和amf数组 */\n    if (ngx_rtmp_init_events(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    /* 调用各RTMP模块的postconfiguration */\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n\n        if (module-&gt;postconfiguration) {\n            if (module-&gt;postconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    // 恢复conf\n    *cf = pcf;\n\n    /* 初始化RTMP各事件响应函数，AMF各事件响应函数及hash表 */\n    if (ngx_rtmp_init_event_handlers(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    /* 初始化端口数组 */\n    if (ngx_array_init(&amp;ports, cf-&gt;temp_pool, 4, sizeof(ngx_rtmp_conf_port_t))\n        != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    listen = cmcf-&gt;listen.elts;\n\n    // 添加listen地址到port数组\n    for (i = 0; i &lt; cmcf-&gt;listen.nelts; i++) {\n        if (ngx_rtmp_add_ports(cf, &amp;ports, &amp;listen[i]) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    /* 将port中的监听地址添加到nginx的监听列表 */\n    return ngx_rtmp_optimize_servers(cf, &amp;ports);\n}\n</code></pre><p>仅看根模块的rtmp{}块解析还无法全面了解配置解析过程，下面贴出另一个重要模块，core模块，的server{}块和applicaiton{}块解析过程，他们在ngx_rtmp_core_module.c中。</p>\n<pre><code>static char *\nngx_rtmp_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf/*srv_conf*/)\n{\n    char                       *rv;\n    void                       *mconf;\n    ngx_uint_t                  m;\n    ngx_conf_t                  pcf;\n    ngx_rtmp_module_t          *module;\n    ngx_rtmp_conf_ctx_t        *ctx, *rtmp_ctx;\n    ngx_rtmp_core_srv_conf_t   *cscf, **cscfp;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    // 每解析到一个server就创建一个新的conf_ctx\n    ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    rtmp_ctx = cf-&gt;ctx;\n    // 使用rtmp级conf_ctx的main_conf覆盖新建的本server的main_conf，以保证唯一的main_conf数组\n    ctx-&gt;main_conf = rtmp_ctx-&gt;main_conf;\n\n    /* the server{}&apos;s srv_conf */\n    /* 为srv_conf和app_conf申请内存 */\n\n    ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx-&gt;srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ctx-&gt;app_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx-&gt;app_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    // 初始化srv_conf和app_conf\n    // 调用各RTMP模块的create_srv_conf和create_app_conf\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n\n        if (module-&gt;create_srv_conf) {\n            mconf = module-&gt;create_srv_conf(cf);\n            if (mconf == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx-&gt;srv_conf[ngx_modules[m]-&gt;ctx_index] = mconf;\n        }\n\n        if (module-&gt;create_app_conf) {\n            mconf = module-&gt;create_app_conf(cf);\n            if (mconf == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx-&gt;app_conf[ngx_modules[m]-&gt;ctx_index] = mconf;\n        }\n    }\n\n    /* the server configuration context */\n    /* 将新申请的conf_ctx放入main_conf的servers数组\n     * servers数组是ngx_rtmp_core_srv_conf_t的集合*/\n    cscf = ctx-&gt;srv_conf[ngx_rtmp_core_module.ctx_index];\n    cscf-&gt;ctx = ctx; // 自我链接，用于下一步放入servers\n    /* 至此，解析server{}块配置的过程实际上就结束了，需要合并配置时，main_conf[core_module]-&gt;servers[...]-&gt;ctx-&gt;srv_conf[core_module]即可找到每一server{}块的配置，\n     * application{}块的解析也同样如此，不同的时application块中也有applications[]数组，因此需要递归的合并子模块的配置\n     */\n\n    cmcf = ctx-&gt;main_conf[ngx_rtmp_core_module.ctx_index];\n\n    cscfp = ngx_array_push(&amp;cmcf-&gt;servers);/* 由于main_conf是直接覆盖而非另外生成，因此这里放入的servers数组就是输入的main_conf */\n    if (cscfp == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *cscfp = cscf;\n\n    /* parse inside server{} \n     * 进入server{}块内部继续解析，这里仅解析NGX_RTMP_SRV_CONF类型的命令，包括listen和application等命令。\n    */\n\n    pcf = *cf;\n    cf-&gt;ctx = ctx;\n    cf-&gt;cmd_type = NGX_RTMP_SRV_CONF;\n\n    rv = ngx_conf_parse(cf, NULL);\n\n    *cf = pcf;\n\n    return rv;\n}\n</code></pre><h3 id=\"TODO-接受PUSH-RTMP流：\"><a href=\"#TODO-接受PUSH-RTMP流：\" class=\"headerlink\" title=\"TODO 接受PUSH RTMP流：\"></a>TODO 接受PUSH RTMP流：</h3><p>##参考：<br>Nginx模块开发入门 <a href=\"http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html\" target=\"_blank\" rel=\"noopener\">http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html</a></p>\n<p>Emiller’s Guide To Nginx Module Development <a href=\"http://www.evanmiller.org/nginx-modules-guide.html\" target=\"_blank\" rel=\"noopener\">http://www.evanmiller.org/nginx-modules-guide.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>##项目主页:<br><a href=\"https://github.com/arut/nginx-rtmp-module\" target=\"_blank\" rel=\"noopener\">https://github.com/arut/nginx-rtmp-module</a></p>\n<p>##项目介绍：<br>nginx-rtmp-module是为nginx开发的一组模块，实现基于nginx的流媒体服务器，包括流发布，转发，录制等功能。具体参考项目主页及项目wiki。</p>\n<p>注意，该项目正在开发中，某些功能尚不稳定，代码结构也可能在将来发生较大的变化。</p>\n<p>##总结</p>\n<p>###配置解析<br>配置解析要从rtmp命令开始，这是一个顶级命令，和http、events等平级。通过阅读代码能看出来，该命令的解析参考了http的解析流程，具体代码位于nginx_rtmp.c中，如果以前对http命令解析过程有了解，相信这里也能很快理解。</p>\n<p>nginx-rtmp-module项目实现的是一组模块，这里为了描述方便，仅用短命名表示各模块，比如core模块，hls模块等，需要注意的是nginx_rtmp.c中声明的模块，这里称呼他为根模块。</p>\n<p>这是一份常见也很典型的rtmp模块配置：</p>\n<pre><code>rtmp {\n    server {\n\n        listen 1935; # 监听1935端口\n\n        application live {\n            live on; # 启用直播   \n\n            hls on;  # 启用HLS\n            hls_path /tmp/tv26; # HLS缓存路径\n\n            recorder record_tv26{ # 启用录制\n                record all; # 收录音视频\n                record_path /tmp/rec; # 收录路径\n            }   \n        }   \n    }   \n</code></pre><p>具体解析部分如下：</p>\n<pre><code>/* rtmp{}块解析函数，一切与rtmp有关的配置解析从这里开始 */\nstatic char *\nngx_rtmp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                        *rv;\n    ngx_uint_t                   i, m, mi, s;\n    ngx_conf_t                   pcf;\n    ngx_array_t                  ports;\n    ngx_rtmp_listen_t           *listen;\n    ngx_rtmp_module_t           *module;\n    ngx_rtmp_conf_ctx_t         *ctx;\n    ngx_rtmp_core_srv_conf_t    *cscf, **cscfp;\n    ngx_rtmp_core_main_conf_t   *cmcf;\n\n    /* \n    typedef struct {\n        void                  **main_conf;\n        void                  **srv_conf;\n        void                  **app_conf;\n    } ngx_rtmp_conf_ctx_t;\n     * 这个结构体再配置解析过程中见到非常多，server命令和application命令解析时也会创建一个这样的结构体，需要注意的时，这个结构体中main_conf是一次rtmp{}块解析过程中唯一的，其他命令解析到的配置将直接修改该main_conf，与另两个结构体不同。\n     */\n    ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *(ngx_rtmp_conf_ctx_t **) conf = ctx;\n\n    /* count the number of the rtmp modules and set up their indices */\n    /* 计算RTMP模块总数，并为模块编号 */\n\n    ngx_rtmp_max_module = 0;\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        ngx_modules[m]-&gt;ctx_index = ngx_rtmp_max_module++;\n    }\n\n\n    /* the rtmp main_conf context, it is the same in the all rtmp contexts */\n    /* 再次强调，创建main_conf上下文变量，全局唯一 */\n    ctx-&gt;main_conf = ngx_pcalloc(cf-&gt;pool,\n                                 sizeof(void *) * ngx_rtmp_max_module);// 这里使用了max创建数组\n    if (ctx-&gt;main_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * the rtmp null srv_conf context, it is used to merge\n     * the server{}s&apos; srv_conf&apos;s\n     * 创建srv_conf上下文变量\n     */\n\n    ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx-&gt;srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * the rtmp null app_conf context, it is used to merge\n     * the server{}s&apos; app_conf&apos;s\n     * 创建app_conf上下文变量\n     */\n\n    ctx-&gt;app_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx-&gt;app_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * create the main_conf&apos;s, the null srv_conf&apos;s, and the null app_conf&apos;s\n     * of the all rtmp modules\n     */\n    /* 遍历所有的RTMP模块，保证所有模块对应的conf不为空 */\n\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n        mi = ngx_modules[m]-&gt;ctx_index;\n\n        // 分别调用各模块的:\n        // create_main_conf，\n        // create_srv_conf\n        // create_app_conf\n        if (module-&gt;create_main_conf) {\n            ctx-&gt;main_conf[mi] = module-&gt;create_main_conf(cf);\n            if (ctx-&gt;main_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module-&gt;create_srv_conf) {\n            ctx-&gt;srv_conf[mi] = module-&gt;create_srv_conf(cf);\n            if (ctx-&gt;srv_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module-&gt;create_app_conf) {\n            ctx-&gt;app_conf[mi] = module-&gt;create_app_conf(cf);\n            if (ctx-&gt;app_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    // 备份ngx_conf_t，在rtmp{}块解析完成后恢复\n    pcf = *cf;\n    cf-&gt;ctx = ctx;\n\n    // 调用各RTMP模块的preconfiguration\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n\n        if (module-&gt;preconfiguration) {\n            if (module-&gt;preconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    /* parse inside the rtmp{} block */\n    /* 进入rtmp{}块中继续解析配置，仅解析cmd_type=NGX_RTMP_MAIN_CONF的指令，比如server{}块。\n     * 这里要回顾一下ngx_rtmp_conf_ctx_t结构体，因为接下来的解析过程，实际上就是填充这三个结构体的过程。\n     * 结构体包括三个数组，分别是main_conf，srv_conf和app_conf，\n     * main_conf实际上一个ngx_rtmp_*_main_conf_t的数组，其中最重要的可能就是core模块的结构，\n\n        typedef struct {\n            ngx_array_t             servers;    // ngx_rtmp_core_srv_conf_t \n            ngx_array_t             listen;     // ngx_rtmp_listen_t \n\n            ngx_array_t             events[NGX_RTMP_MAX_EVENT];\n\n            ngx_hash_t              amf_hash;\n            ngx_array_t             amf_arrays;\n            ngx_array_t             amf;\n        } ngx_rtmp_core_main_conf_t;\n\n     * 解析到的server{}块配置会保存到core模块的servers数组中\n     * 同样的，srv_conf是一个ngx_rtmp_*_srv_main_t的数组，其中最重要的是core模块中针对server配置的结构体，\n\n        typedef struct ngx_rtmp_core_srv_conf_s {\n            ngx_array_t             applications; // ngx_rtmp_core_app_conf_t\n            ...            \n            ngx_rtmp_conf_ctx_t    *ctx;\n        } ngx_rtmp_core_srv_conf_t;\n\n     * 解析到的application{}块会保存到相应server块的applications数组中 */\n\n    cf-&gt;module_type = NGX_RTMP_MODULE;\n    cf-&gt;cmd_type = NGX_RTMP_MAIN_CONF;\n    rv = ngx_conf_parse(cf, NULL);\n\n    if (rv != NGX_CONF_OK) {\n        *cf = pcf;\n        return rv;\n    }\n\n\n    /* init rtmp{} main_conf&apos;s, merge the server{}s&apos; srv_conf&apos;s */\n\n    // cmcf =&gt; core module conf\n    cmcf = ctx-&gt;main_conf[ngx_rtmp_core_module.ctx_index];\n    cscfp = cmcf-&gt;servers.elts;\n\n    /* 合并各RTMP模块配置 \n     * 这里的合并有一点需要注意的是，core模块的配置必须首先被合并，这个通过写config文件来实现，只有这样，才能保证上一轮解析中的配置全部合并到ctx的三大数组中。\n     * 跟模块不在这一轮合并中出现，因为根模块的类型不是NGX_RTMP_MODULE而是NGX_CORE_MODULE\n     */\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n        // mi =&gt; module_index\n        mi = ngx_modules[m]-&gt;ctx_index;\n\n        /* init rtmp{} main_conf&apos;s */\n        /* 调用各main模块的init_main_conf */\n\n        cf-&gt;ctx = ctx;\n\n        // 调用各RTMP main模块的init_main_conf，因为全局统一使用一个main_conf数组，因此这里不需要“merge”\n        if (module-&gt;init_main_conf) {\n            rv = module-&gt;init_main_conf(cf, ctx-&gt;main_conf[mi]);\n            if (rv != NGX_CONF_OK) {\n                *cf = pcf;\n                return rv;\n            }\n        }\n\n        /* 分别调用各模块merge_srv_conf和merge_app_conf，如果需要的话\n         * ngx_parse_conf产生的servers用在这里*/\n        for (s = 0; s &lt; cmcf-&gt;servers.nelts; s++) {\n\n            /* merge the server{}s&apos; srv_conf&apos;s */\n\n            cf-&gt;ctx = cscfp[s]-&gt;ctx;\n\n            if (module-&gt;merge_srv_conf) {\n                rv = module-&gt;merge_srv_conf(cf,\n                                            ctx-&gt;srv_conf[mi],\n                                            cscfp[s]-&gt;ctx-&gt;srv_conf[mi]);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n            }\n\n            if (module-&gt;merge_app_conf) {\n\n                /* merge the server{}&apos;s app_conf */\n\n                /*ctx-&gt;app_conf = cscfp[s]-&gt;ctx-&gt;loc_conf;*/\n\n                rv = module-&gt;merge_app_conf(cf, \n                                            ctx-&gt;app_conf[mi],\n                                            cscfp[s]-&gt;ctx-&gt;app_conf[mi]);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n\n                /* merge the applications{}&apos; app_conf&apos;s \n                 * 解析applications数组\n                 * cscfp = core server conf pointer*/\n\n                cscf = cscfp[s]-&gt;ctx-&gt;srv_conf[ngx_rtmp_core_module.ctx_index];\n\n                /* 递归的解析applications数组，因为application有可能有子块，比如recorder{}块 */\n                rv = ngx_rtmp_merge_applications(cf, &amp;cscf-&gt;applications,\n                                            cscfp[s]-&gt;ctx-&gt;app_conf,\n                                            module, mi);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n            }\n\n        }\n    }\n\n\n    /* 初始化events数组和amf数组 */\n    if (ngx_rtmp_init_events(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    /* 调用各RTMP模块的postconfiguration */\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n\n        if (module-&gt;postconfiguration) {\n            if (module-&gt;postconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    // 恢复conf\n    *cf = pcf;\n\n    /* 初始化RTMP各事件响应函数，AMF各事件响应函数及hash表 */\n    if (ngx_rtmp_init_event_handlers(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    /* 初始化端口数组 */\n    if (ngx_array_init(&amp;ports, cf-&gt;temp_pool, 4, sizeof(ngx_rtmp_conf_port_t))\n        != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    listen = cmcf-&gt;listen.elts;\n\n    // 添加listen地址到port数组\n    for (i = 0; i &lt; cmcf-&gt;listen.nelts; i++) {\n        if (ngx_rtmp_add_ports(cf, &amp;ports, &amp;listen[i]) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    /* 将port中的监听地址添加到nginx的监听列表 */\n    return ngx_rtmp_optimize_servers(cf, &amp;ports);\n}\n</code></pre><p>仅看根模块的rtmp{}块解析还无法全面了解配置解析过程，下面贴出另一个重要模块，core模块，的server{}块和applicaiton{}块解析过程，他们在ngx_rtmp_core_module.c中。</p>\n<pre><code>static char *\nngx_rtmp_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf/*srv_conf*/)\n{\n    char                       *rv;\n    void                       *mconf;\n    ngx_uint_t                  m;\n    ngx_conf_t                  pcf;\n    ngx_rtmp_module_t          *module;\n    ngx_rtmp_conf_ctx_t        *ctx, *rtmp_ctx;\n    ngx_rtmp_core_srv_conf_t   *cscf, **cscfp;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    // 每解析到一个server就创建一个新的conf_ctx\n    ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    rtmp_ctx = cf-&gt;ctx;\n    // 使用rtmp级conf_ctx的main_conf覆盖新建的本server的main_conf，以保证唯一的main_conf数组\n    ctx-&gt;main_conf = rtmp_ctx-&gt;main_conf;\n\n    /* the server{}&apos;s srv_conf */\n    /* 为srv_conf和app_conf申请内存 */\n\n    ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx-&gt;srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ctx-&gt;app_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx-&gt;app_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    // 初始化srv_conf和app_conf\n    // 调用各RTMP模块的create_srv_conf和create_app_conf\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]-&gt;type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]-&gt;ctx;\n\n        if (module-&gt;create_srv_conf) {\n            mconf = module-&gt;create_srv_conf(cf);\n            if (mconf == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx-&gt;srv_conf[ngx_modules[m]-&gt;ctx_index] = mconf;\n        }\n\n        if (module-&gt;create_app_conf) {\n            mconf = module-&gt;create_app_conf(cf);\n            if (mconf == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx-&gt;app_conf[ngx_modules[m]-&gt;ctx_index] = mconf;\n        }\n    }\n\n    /* the server configuration context */\n    /* 将新申请的conf_ctx放入main_conf的servers数组\n     * servers数组是ngx_rtmp_core_srv_conf_t的集合*/\n    cscf = ctx-&gt;srv_conf[ngx_rtmp_core_module.ctx_index];\n    cscf-&gt;ctx = ctx; // 自我链接，用于下一步放入servers\n    /* 至此，解析server{}块配置的过程实际上就结束了，需要合并配置时，main_conf[core_module]-&gt;servers[...]-&gt;ctx-&gt;srv_conf[core_module]即可找到每一server{}块的配置，\n     * application{}块的解析也同样如此，不同的时application块中也有applications[]数组，因此需要递归的合并子模块的配置\n     */\n\n    cmcf = ctx-&gt;main_conf[ngx_rtmp_core_module.ctx_index];\n\n    cscfp = ngx_array_push(&amp;cmcf-&gt;servers);/* 由于main_conf是直接覆盖而非另外生成，因此这里放入的servers数组就是输入的main_conf */\n    if (cscfp == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *cscfp = cscf;\n\n    /* parse inside server{} \n     * 进入server{}块内部继续解析，这里仅解析NGX_RTMP_SRV_CONF类型的命令，包括listen和application等命令。\n    */\n\n    pcf = *cf;\n    cf-&gt;ctx = ctx;\n    cf-&gt;cmd_type = NGX_RTMP_SRV_CONF;\n\n    rv = ngx_conf_parse(cf, NULL);\n\n    *cf = pcf;\n\n    return rv;\n}\n</code></pre><h3 id=\"TODO-接受PUSH-RTMP流：\"><a href=\"#TODO-接受PUSH-RTMP流：\" class=\"headerlink\" title=\"TODO 接受PUSH RTMP流：\"></a>TODO 接受PUSH RTMP流：</h3><p>##参考：<br>Nginx模块开发入门 <a href=\"http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html\" target=\"_blank\" rel=\"noopener\">http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html</a></p>\n<p>Emiller’s Guide To Nginx Module Development <a href=\"http://www.evanmiller.org/nginx-modules-guide.html\" target=\"_blank\" rel=\"noopener\">http://www.evanmiller.org/nginx-modules-guide.html</a></p>\n"},{"layout":"post","title":"Fix: librtmp not found in ffmpeg","description":"解决编译ffmpeg过程中出现的librtmp not found错误","category":null,"_content":"\n\n服务器的yum坏了，运维的同事说“无解”，好吧，好吧……\n\n手动编译ffmpeg，配置参数为\n\n\t./configure --enable-libfaac --enable-libx264 --enable-nonfree --enable-gpl --enable-librtmp\n   \n然后就一直停在\n\n    “librtmp not found”\n   \n下载编译了librtmp，搞定了头文件和库的链接还是报这个错，检查config.log发现check_pkg_config这个调用出错了，再看configure，这个调用貌似是检查librtmp这个包的安装情况，也许是手动安装没有更新包信息导致的。\n\n找到configure中对应librtmp检查的那行，可能长这样\n\n    enabled librtmp    && require_pkg_config librtmp librtmp/rtmp.h RTMP_Socket\n   \n注释该行，再配置一次，通过了。\n\n经过这样的修改，编译时可能会报错，librtmp中的一些函数未定义，可以修改config.mak，找到EXTRALIBS这个宏，在后面追加“-lrtmp”即可。\n\n","source":"_posts/2013-09-30-fix-ffmpeg-librtmp-not-found.md","raw":"---\nlayout: post\ntitle: \"Fix: librtmp not found in ffmpeg\"\ndescription: \"解决编译ffmpeg过程中出现的librtmp not found错误\"\ncategory: \ntags: [ffmpeg, librtmp]\n---\n\n\n服务器的yum坏了，运维的同事说“无解”，好吧，好吧……\n\n手动编译ffmpeg，配置参数为\n\n\t./configure --enable-libfaac --enable-libx264 --enable-nonfree --enable-gpl --enable-librtmp\n   \n然后就一直停在\n\n    “librtmp not found”\n   \n下载编译了librtmp，搞定了头文件和库的链接还是报这个错，检查config.log发现check_pkg_config这个调用出错了，再看configure，这个调用貌似是检查librtmp这个包的安装情况，也许是手动安装没有更新包信息导致的。\n\n找到configure中对应librtmp检查的那行，可能长这样\n\n    enabled librtmp    && require_pkg_config librtmp librtmp/rtmp.h RTMP_Socket\n   \n注释该行，再配置一次，通过了。\n\n经过这样的修改，编译时可能会报错，librtmp中的一些函数未定义，可以修改config.mak，找到EXTRALIBS这个宏，在后面追加“-lrtmp”即可。\n\n","slug":"fix-ffmpeg-librtmp-not-found","published":1,"date":"2013-09-29T16:00:00.000Z","updated":"2018-03-07T06:11:13.304Z","comments":1,"photos":[],"link":"","_id":"cjegotuqe000ai0fo6han9mb5","content":"<p>服务器的yum坏了，运维的同事说“无解”，好吧，好吧……</p>\n<p>手动编译ffmpeg，配置参数为</p>\n<pre><code>./configure --enable-libfaac --enable-libx264 --enable-nonfree --enable-gpl --enable-librtmp\n</code></pre><p>然后就一直停在</p>\n<pre><code>“librtmp not found”\n</code></pre><p>下载编译了librtmp，搞定了头文件和库的链接还是报这个错，检查config.log发现check_pkg_config这个调用出错了，再看configure，这个调用貌似是检查librtmp这个包的安装情况，也许是手动安装没有更新包信息导致的。</p>\n<p>找到configure中对应librtmp检查的那行，可能长这样</p>\n<pre><code>enabled librtmp    &amp;&amp; require_pkg_config librtmp librtmp/rtmp.h RTMP_Socket\n</code></pre><p>注释该行，再配置一次，通过了。</p>\n<p>经过这样的修改，编译时可能会报错，librtmp中的一些函数未定义，可以修改config.mak，找到EXTRALIBS这个宏，在后面追加“-lrtmp”即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>服务器的yum坏了，运维的同事说“无解”，好吧，好吧……</p>\n<p>手动编译ffmpeg，配置参数为</p>\n<pre><code>./configure --enable-libfaac --enable-libx264 --enable-nonfree --enable-gpl --enable-librtmp\n</code></pre><p>然后就一直停在</p>\n<pre><code>“librtmp not found”\n</code></pre><p>下载编译了librtmp，搞定了头文件和库的链接还是报这个错，检查config.log发现check_pkg_config这个调用出错了，再看configure，这个调用貌似是检查librtmp这个包的安装情况，也许是手动安装没有更新包信息导致的。</p>\n<p>找到configure中对应librtmp检查的那行，可能长这样</p>\n<pre><code>enabled librtmp    &amp;&amp; require_pkg_config librtmp librtmp/rtmp.h RTMP_Socket\n</code></pre><p>注释该行，再配置一次，通过了。</p>\n<p>经过这样的修改，编译时可能会报错，librtmp中的一些函数未定义，可以修改config.mak，找到EXTRALIBS这个宏，在后面追加“-lrtmp”即可。</p>\n"},{"layout":"post","title":"Fix: Nexus 7(2013) Wifi OTG Storage Issue","description":"解决二代N7无法使用OTG存储设备的问题","category":null,"_content":"\n需要安装Nexus Photo Viewer([Google Play](https://play.google.com/store/apps/details?id=com.homeysoft.nexususb.viewer))，依据软件开发者的博客([blogspot](http://nexususb.blogspot.com/))提供的解决方案即可解决。\n\n下面是软件开发者提供的解决步骤：\n\n1. Hold the device in Portrait Mode（竖屏）\n2. Open Android Settings and make the following __temporary__ changes（以下步骤修改的配置，可在问题解决后恢复）\n3. Under Security -> Lock Screen.  Select None（取消密码、图案锁屏等）\n4. Under Accessibility -> Auto-rotate screen.  Make sure it is NOT checked（取消自动旋转屏幕）\n5. __(Nexus 7 2013 Only)__ Under Language and input -> English (United States)（__语言改为美式英文__）\n6. Open NMI/NPV manually via the icon.（打开Nexus Photo Viewer）\n7. Connect the OTG and Flash/Pen Drive（连接OTS存储设备）\n8. Press and Hold Power until you see \"Power Off\"（关机）\n9. Tap OK to Power Off\n10. Power On（开机）\n11. Repeat steps 8-10 until you see this prompt or NMI opens automatically.  If you have repeated this more than 5 times see below.\\*（重复8～10，直到Nexus Photo Viewer开机自动打开，并且可以浏览OTG存储设备内容，软件开发者博客提供了效果图）\n\n---\n\n2013-10-10 更新\n\n按照上述方法虽然能够解决二代N7的OTG存储设备使用问题，但是会导致机器__极其不稳定__。\n\n这种不稳定将直接导致机器__重启__，并在重启之后恢复正常，当然OTG功能又不见了……","source":"_posts/2013-09-29-fix-nexus-7-2013-otg-storage.md","raw":"---\nlayout: post\ntitle: \"Fix: Nexus 7(2013) Wifi OTG Storage Issue\"\ndescription: \"解决二代N7无法使用OTG存储设备的问题\"\ncategory: \ntags: [Nexus, OTG]\n---\n\n需要安装Nexus Photo Viewer([Google Play](https://play.google.com/store/apps/details?id=com.homeysoft.nexususb.viewer))，依据软件开发者的博客([blogspot](http://nexususb.blogspot.com/))提供的解决方案即可解决。\n\n下面是软件开发者提供的解决步骤：\n\n1. Hold the device in Portrait Mode（竖屏）\n2. Open Android Settings and make the following __temporary__ changes（以下步骤修改的配置，可在问题解决后恢复）\n3. Under Security -> Lock Screen.  Select None（取消密码、图案锁屏等）\n4. Under Accessibility -> Auto-rotate screen.  Make sure it is NOT checked（取消自动旋转屏幕）\n5. __(Nexus 7 2013 Only)__ Under Language and input -> English (United States)（__语言改为美式英文__）\n6. Open NMI/NPV manually via the icon.（打开Nexus Photo Viewer）\n7. Connect the OTG and Flash/Pen Drive（连接OTS存储设备）\n8. Press and Hold Power until you see \"Power Off\"（关机）\n9. Tap OK to Power Off\n10. Power On（开机）\n11. Repeat steps 8-10 until you see this prompt or NMI opens automatically.  If you have repeated this more than 5 times see below.\\*（重复8～10，直到Nexus Photo Viewer开机自动打开，并且可以浏览OTG存储设备内容，软件开发者博客提供了效果图）\n\n---\n\n2013-10-10 更新\n\n按照上述方法虽然能够解决二代N7的OTG存储设备使用问题，但是会导致机器__极其不稳定__。\n\n这种不稳定将直接导致机器__重启__，并在重启之后恢复正常，当然OTG功能又不见了……","slug":"fix-nexus-7-2013-otg-storage","published":1,"date":"2013-09-28T16:00:00.000Z","updated":"2018-03-07T06:11:13.303Z","comments":1,"photos":[],"link":"","_id":"cjegoturd000xi0fo98834wug","content":"<p>需要安装Nexus Photo Viewer(<a href=\"https://play.google.com/store/apps/details?id=com.homeysoft.nexususb.viewer\" target=\"_blank\" rel=\"noopener\">Google Play</a>)，依据软件开发者的博客(<a href=\"http://nexususb.blogspot.com/\" target=\"_blank\" rel=\"noopener\">blogspot</a>)提供的解决方案即可解决。</p>\n<p>下面是软件开发者提供的解决步骤：</p>\n<ol>\n<li>Hold the device in Portrait Mode（竖屏）</li>\n<li>Open Android Settings and make the following <strong>temporary</strong> changes（以下步骤修改的配置，可在问题解决后恢复）</li>\n<li>Under Security -&gt; Lock Screen.  Select None（取消密码、图案锁屏等）</li>\n<li>Under Accessibility -&gt; Auto-rotate screen.  Make sure it is NOT checked（取消自动旋转屏幕）</li>\n<li><strong>(Nexus 7 2013 Only)</strong> Under Language and input -&gt; English (United States)（<strong>语言改为美式英文</strong>）</li>\n<li>Open NMI/NPV manually via the icon.（打开Nexus Photo Viewer）</li>\n<li>Connect the OTG and Flash/Pen Drive（连接OTS存储设备）</li>\n<li>Press and Hold Power until you see “Power Off”（关机）</li>\n<li>Tap OK to Power Off</li>\n<li>Power On（开机）</li>\n<li>Repeat steps 8-10 until you see this prompt or NMI opens automatically.  If you have repeated this more than 5 times see below.*（重复8～10，直到Nexus Photo Viewer开机自动打开，并且可以浏览OTG存储设备内容，软件开发者博客提供了效果图）</li>\n</ol>\n<hr>\n<p>2013-10-10 更新</p>\n<p>按照上述方法虽然能够解决二代N7的OTG存储设备使用问题，但是会导致机器<strong>极其不稳定</strong>。</p>\n<p>这种不稳定将直接导致机器<strong>重启</strong>，并在重启之后恢复正常，当然OTG功能又不见了……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>需要安装Nexus Photo Viewer(<a href=\"https://play.google.com/store/apps/details?id=com.homeysoft.nexususb.viewer\" target=\"_blank\" rel=\"noopener\">Google Play</a>)，依据软件开发者的博客(<a href=\"http://nexususb.blogspot.com/\" target=\"_blank\" rel=\"noopener\">blogspot</a>)提供的解决方案即可解决。</p>\n<p>下面是软件开发者提供的解决步骤：</p>\n<ol>\n<li>Hold the device in Portrait Mode（竖屏）</li>\n<li>Open Android Settings and make the following <strong>temporary</strong> changes（以下步骤修改的配置，可在问题解决后恢复）</li>\n<li>Under Security -&gt; Lock Screen.  Select None（取消密码、图案锁屏等）</li>\n<li>Under Accessibility -&gt; Auto-rotate screen.  Make sure it is NOT checked（取消自动旋转屏幕）</li>\n<li><strong>(Nexus 7 2013 Only)</strong> Under Language and input -&gt; English (United States)（<strong>语言改为美式英文</strong>）</li>\n<li>Open NMI/NPV manually via the icon.（打开Nexus Photo Viewer）</li>\n<li>Connect the OTG and Flash/Pen Drive（连接OTS存储设备）</li>\n<li>Press and Hold Power until you see “Power Off”（关机）</li>\n<li>Tap OK to Power Off</li>\n<li>Power On（开机）</li>\n<li>Repeat steps 8-10 until you see this prompt or NMI opens automatically.  If you have repeated this more than 5 times see below.*（重复8～10，直到Nexus Photo Viewer开机自动打开，并且可以浏览OTG存储设备内容，软件开发者博客提供了效果图）</li>\n</ol>\n<hr>\n<p>2013-10-10 更新</p>\n<p>按照上述方法虽然能够解决二代N7的OTG存储设备使用问题，但是会导致机器<strong>极其不稳定</strong>。</p>\n<p>这种不稳定将直接导致机器<strong>重启</strong>，并在重启之后恢复正常，当然OTG功能又不见了……</p>\n"},{"layout":"post","title":"使用ffmpeg为视频打码","description":"ffmpeg提供的滤镜为视频打码","category":null,"_content":"\n涉及的滤镜包括:crop，boxblur和overlay。\n\n示例：\n\n\tffmpeg -i input.mp4 -vf \"[in]split[blurin][originalin] [blurin]crop=60:30:in_w-70:10,boxblur=5:5[blurout];[originalin][blurout]overlay=x=main_w-70:y=10[out]\" -y output.mp4\n\n其中，\n\n\t“60:30”为马赛克面积\n\t\n\t“in_w-70:10”为马赛克位置\n\t\n\tboxblur的参数决定了马赛克的模糊程度\n\ncrop滤镜和overlay滤镜的位置相同效果最好。","source":"_posts/2013-10-10-ffmpeg-mosaic.md","raw":"---\nlayout: post\ntitle: \"使用ffmpeg为视频打码\"\ndescription: \"ffmpeg提供的滤镜为视频打码\"\ncategory: \ntags: [ffmpeg]\n---\n\n涉及的滤镜包括:crop，boxblur和overlay。\n\n示例：\n\n\tffmpeg -i input.mp4 -vf \"[in]split[blurin][originalin] [blurin]crop=60:30:in_w-70:10,boxblur=5:5[blurout];[originalin][blurout]overlay=x=main_w-70:y=10[out]\" -y output.mp4\n\n其中，\n\n\t“60:30”为马赛克面积\n\t\n\t“in_w-70:10”为马赛克位置\n\t\n\tboxblur的参数决定了马赛克的模糊程度\n\ncrop滤镜和overlay滤镜的位置相同效果最好。","slug":"ffmpeg-mosaic","published":1,"date":"2013-10-09T16:00:00.000Z","updated":"2018-03-07T06:11:13.305Z","comments":1,"photos":[],"link":"","_id":"cjegoturg000yi0fo5cxlwi4y","content":"<p>涉及的滤镜包括:crop，boxblur和overlay。</p>\n<p>示例：</p>\n<pre><code>ffmpeg -i input.mp4 -vf &quot;[in]split[blurin][originalin] [blurin]crop=60:30:in_w-70:10,boxblur=5:5[blurout];[originalin][blurout]overlay=x=main_w-70:y=10[out]&quot; -y output.mp4\n</code></pre><p>其中，</p>\n<pre><code>“60:30”为马赛克面积\n\n“in_w-70:10”为马赛克位置\n\nboxblur的参数决定了马赛克的模糊程度\n</code></pre><p>crop滤镜和overlay滤镜的位置相同效果最好。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>涉及的滤镜包括:crop，boxblur和overlay。</p>\n<p>示例：</p>\n<pre><code>ffmpeg -i input.mp4 -vf &quot;[in]split[blurin][originalin] [blurin]crop=60:30:in_w-70:10,boxblur=5:5[blurout];[originalin][blurout]overlay=x=main_w-70:y=10[out]&quot; -y output.mp4\n</code></pre><p>其中，</p>\n<pre><code>“60:30”为马赛克面积\n\n“in_w-70:10”为马赛克位置\n\nboxblur的参数决定了马赛克的模糊程度\n</code></pre><p>crop滤镜和overlay滤镜的位置相同效果最好。</p>\n"},{"layout":"post","title":"尝试从Wordpress迁移到Github Pages","description":"导出Wordpress数据，安装jekyll-import工具，完成迁移。","category":null,"_content":"\n\n我的另一个博客[sqbing.com](http://sqbing.com)使用Wordpress，目前挂在Appfog的免费主机上。当我们使用免费产品时，我们自己就变成了别人的产品。这个免费主机有很多问题，插件不时被删除，图片不时被删除，备份又麻烦。\n\n参考[Jekyll](http://jekyllrb.com/docs/migrations/)提供的博客迁移方法，主要是jekyll-import工具的安装，我使用的是Ubuntu 12.04，默认ruby版本是1.8，需要安装最新版本的ruby。如果已经安装了合适版本的ruby，直接运行第3步。\n\n1. 从[ruby官网](https://www.ruby-lang.org/zh_cn/)下载ruby 2.0.0源码包\n\n\t\t解压源码包\n\t\t进入源码目录，执行./configure\n\t\tmake\n\t\tsudo make install\n\n2. 使用update-alternatives修改默认ruby\n\n\t\tsudo update-alternatives --install /usr/bin/ruby ruby /usr/local/bin/ruby\n\t\tsudo update-alternatives --config ruby\n\t\t根据提示选择/usr/local/bin/ruby\n\t\t\n3. 安装jekyll-import\n\n\t\tgem install jekyll-import --pre\n\t\tgem install hpricot\n\n4. 解析Wordpress导出文件\n\n\t\truby -rubygems -e 'require \"jekyll/jekyll-import/wordpressdotcom\";\n    \t\tJekyllImport::WordpressDotCom.process({ :source => \"wordpress.xml\" })'\n    \t这里的wordpress.xml是文件名\n    \t\n导出结果不是很让人满意，排版一塌糊涂，不过总比一篇篇的复制要强，找时间再重排版吧。\n\n另外，如果嫌gem速度慢，试试换成taobao的源。\n\n\tgem sources --remove https://rubygems.org/\n\tgem sources -a http://ruby.taobao.org/\n\tgem sources -l\n\t*** CURRENT SOURCES ***\n\t \n\thttp://ruby.taobao.org","source":"_posts/2013-10-11-from-wordpress-to-github.md","raw":"---\nlayout: post\ntitle: \"尝试从Wordpress迁移到Github Pages\"\ndescription: \"导出Wordpress数据，安装jekyll-import工具，完成迁移。\"\ncategory: \ntags: [wordpress]\n---\n\n\n我的另一个博客[sqbing.com](http://sqbing.com)使用Wordpress，目前挂在Appfog的免费主机上。当我们使用免费产品时，我们自己就变成了别人的产品。这个免费主机有很多问题，插件不时被删除，图片不时被删除，备份又麻烦。\n\n参考[Jekyll](http://jekyllrb.com/docs/migrations/)提供的博客迁移方法，主要是jekyll-import工具的安装，我使用的是Ubuntu 12.04，默认ruby版本是1.8，需要安装最新版本的ruby。如果已经安装了合适版本的ruby，直接运行第3步。\n\n1. 从[ruby官网](https://www.ruby-lang.org/zh_cn/)下载ruby 2.0.0源码包\n\n\t\t解压源码包\n\t\t进入源码目录，执行./configure\n\t\tmake\n\t\tsudo make install\n\n2. 使用update-alternatives修改默认ruby\n\n\t\tsudo update-alternatives --install /usr/bin/ruby ruby /usr/local/bin/ruby\n\t\tsudo update-alternatives --config ruby\n\t\t根据提示选择/usr/local/bin/ruby\n\t\t\n3. 安装jekyll-import\n\n\t\tgem install jekyll-import --pre\n\t\tgem install hpricot\n\n4. 解析Wordpress导出文件\n\n\t\truby -rubygems -e 'require \"jekyll/jekyll-import/wordpressdotcom\";\n    \t\tJekyllImport::WordpressDotCom.process({ :source => \"wordpress.xml\" })'\n    \t这里的wordpress.xml是文件名\n    \t\n导出结果不是很让人满意，排版一塌糊涂，不过总比一篇篇的复制要强，找时间再重排版吧。\n\n另外，如果嫌gem速度慢，试试换成taobao的源。\n\n\tgem sources --remove https://rubygems.org/\n\tgem sources -a http://ruby.taobao.org/\n\tgem sources -l\n\t*** CURRENT SOURCES ***\n\t \n\thttp://ruby.taobao.org","slug":"from-wordpress-to-github","published":1,"date":"2013-10-10T16:00:00.000Z","updated":"2018-03-07T06:11:13.307Z","comments":1,"photos":[],"link":"","_id":"cjegoturj0010i0fof3yio202","content":"<p>我的另一个博客<a href=\"http://sqbing.com\" target=\"_blank\" rel=\"noopener\">sqbing.com</a>使用Wordpress，目前挂在Appfog的免费主机上。当我们使用免费产品时，我们自己就变成了别人的产品。这个免费主机有很多问题，插件不时被删除，图片不时被删除，备份又麻烦。</p>\n<p>参考<a href=\"http://jekyllrb.com/docs/migrations/\" target=\"_blank\" rel=\"noopener\">Jekyll</a>提供的博客迁移方法，主要是jekyll-import工具的安装，我使用的是Ubuntu 12.04，默认ruby版本是1.8，需要安装最新版本的ruby。如果已经安装了合适版本的ruby，直接运行第3步。</p>\n<ol>\n<li><p>从<a href=\"https://www.ruby-lang.org/zh_cn/\" target=\"_blank\" rel=\"noopener\">ruby官网</a>下载ruby 2.0.0源码包</p>\n<pre><code>解压源码包\n进入源码目录，执行./configure\nmake\nsudo make install\n</code></pre></li>\n<li><p>使用update-alternatives修改默认ruby</p>\n<pre><code>sudo update-alternatives --install /usr/bin/ruby ruby /usr/local/bin/ruby\nsudo update-alternatives --config ruby\n根据提示选择/usr/local/bin/ruby\n</code></pre></li>\n<li><p>安装jekyll-import</p>\n<pre><code>gem install jekyll-import --pre\ngem install hpricot\n</code></pre></li>\n<li><p>解析Wordpress导出文件</p>\n<pre><code>ruby -rubygems -e &apos;require &quot;jekyll/jekyll-import/wordpressdotcom&quot;;\n    JekyllImport::WordpressDotCom.process({ :source =&gt; &quot;wordpress.xml&quot; })&apos;\n这里的wordpress.xml是文件名\n</code></pre></li>\n</ol>\n<p>导出结果不是很让人满意，排版一塌糊涂，不过总比一篇篇的复制要强，找时间再重排版吧。</p>\n<p>另外，如果嫌gem速度慢，试试换成taobao的源。</p>\n<pre><code>gem sources --remove https://rubygems.org/\ngem sources -a http://ruby.taobao.org/\ngem sources -l\n*** CURRENT SOURCES ***\n\nhttp://ruby.taobao.org\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>我的另一个博客<a href=\"http://sqbing.com\" target=\"_blank\" rel=\"noopener\">sqbing.com</a>使用Wordpress，目前挂在Appfog的免费主机上。当我们使用免费产品时，我们自己就变成了别人的产品。这个免费主机有很多问题，插件不时被删除，图片不时被删除，备份又麻烦。</p>\n<p>参考<a href=\"http://jekyllrb.com/docs/migrations/\" target=\"_blank\" rel=\"noopener\">Jekyll</a>提供的博客迁移方法，主要是jekyll-import工具的安装，我使用的是Ubuntu 12.04，默认ruby版本是1.8，需要安装最新版本的ruby。如果已经安装了合适版本的ruby，直接运行第3步。</p>\n<ol>\n<li><p>从<a href=\"https://www.ruby-lang.org/zh_cn/\" target=\"_blank\" rel=\"noopener\">ruby官网</a>下载ruby 2.0.0源码包</p>\n<pre><code>解压源码包\n进入源码目录，执行./configure\nmake\nsudo make install\n</code></pre></li>\n<li><p>使用update-alternatives修改默认ruby</p>\n<pre><code>sudo update-alternatives --install /usr/bin/ruby ruby /usr/local/bin/ruby\nsudo update-alternatives --config ruby\n根据提示选择/usr/local/bin/ruby\n</code></pre></li>\n<li><p>安装jekyll-import</p>\n<pre><code>gem install jekyll-import --pre\ngem install hpricot\n</code></pre></li>\n<li><p>解析Wordpress导出文件</p>\n<pre><code>ruby -rubygems -e &apos;require &quot;jekyll/jekyll-import/wordpressdotcom&quot;;\n    JekyllImport::WordpressDotCom.process({ :source =&gt; &quot;wordpress.xml&quot; })&apos;\n这里的wordpress.xml是文件名\n</code></pre></li>\n</ol>\n<p>导出结果不是很让人满意，排版一塌糊涂，不过总比一篇篇的复制要强，找时间再重排版吧。</p>\n<p>另外，如果嫌gem速度慢，试试换成taobao的源。</p>\n<pre><code>gem sources --remove https://rubygems.org/\ngem sources -a http://ruby.taobao.org/\ngem sources -l\n*** CURRENT SOURCES ***\n\nhttp://ruby.taobao.org\n</code></pre>"},{"layout":"post","title":"Write blog with prose.io","description":"尝试使用porse.io维护github pages","category":null,"published":1,"_content":"\nTry to write blog with [__prose.io__](http://prose.io).\n\nProse.io会读取github项目，支持修改文件，只是似乎和jekyll配合的不好，创建出来的文件缺少一些基本的头部，无法正常生成post。\n\n恐怕只能当作是草稿箱来用了。","source":"_posts/2013-10-10-write-blog-with-prose.md","raw":"---\nlayout: post\ntitle: Write blog with prose.io\ndescription: \"尝试使用porse.io维护github pages\"\ncategory: null\ntags: []\npublished: true\n---\n\nTry to write blog with [__prose.io__](http://prose.io).\n\nProse.io会读取github项目，支持修改文件，只是似乎和jekyll配合的不好，创建出来的文件缺少一些基本的头部，无法正常生成post。\n\n恐怕只能当作是草稿箱来用了。","slug":"write-blog-with-prose","date":"2013-10-09T16:00:00.000Z","updated":"2018-03-07T06:11:13.306Z","comments":1,"photos":[],"link":"","_id":"cjegoturl0012i0foad76fyb4","content":"<p>Try to write blog with <a href=\"http://prose.io\" target=\"_blank\" rel=\"noopener\"><strong>prose.io</strong></a>.</p>\n<p>Prose.io会读取github项目，支持修改文件，只是似乎和jekyll配合的不好，创建出来的文件缺少一些基本的头部，无法正常生成post。</p>\n<p>恐怕只能当作是草稿箱来用了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Try to write blog with <a href=\"http://prose.io\" target=\"_blank\" rel=\"noopener\"><strong>prose.io</strong></a>.</p>\n<p>Prose.io会读取github项目，支持修改文件，只是似乎和jekyll配合的不好，创建出来的文件缺少一些基本的头部，无法正常生成post。</p>\n<p>恐怕只能当作是草稿箱来用了。</p>\n"},{"layout":"post","title":"Luabind 学习备忘","description":"总结Lua学习中的注意点。","category":null,"published":0,"_content":"\n1. 绑定C++类到Lua中时，类的生命中一定要提供构造函数，否则产生abort信号。","source":"_posts/2013-10-14-lua-note-1.md","raw":"---\nlayout: post\ntitle: Luabind 学习备忘\ndescription: 总结Lua学习中的注意点。\ncategory: null\ntags: [lua]\npublished: false\n\n---\n\n1. 绑定C++类到Lua中时，类的生命中一定要提供构造函数，否则产生abort信号。","slug":"lua-note-1","date":"2013-10-13T16:00:00.000Z","updated":"2018-03-07T06:11:13.308Z","comments":1,"photos":[],"link":"","_id":"cjegoturn0013i0fo8rez40vg","content":"<ol>\n<li>绑定C++类到Lua中时，类的生命中一定要提供构造函数，否则产生abort信号。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>绑定C++类到Lua中时，类的生命中一定要提供构造函数，否则产生abort信号。</li>\n</ol>\n"},{"layout":"post","title":"Rider's Resume","description":"My personal resume","category":null,"_content":"\n#SUMMARY OF QUALIFICATION\n3 year's working experience in C/C++ software development.\n\nExpertise in network analyzing, media transcoding, and media streaming.\n\nTeam work spirit. High liability and attribution. Be able to work under great pressure.\n\n3年C/C++开发经验，包括网络协议分析（OSI 3层及以下），数据包信息挖掘，媒体处理（MP4、TS、FLV、H.264、AAC），流媒体（RTMP/HLS）\n\n对软件开发充满热情，关注技术潮流\n\n对代码有洁癖，有不断优化代码的强迫症\n\n平台/Platforms: ARM, MIPS, x86\n\n操作系统/Operating Systems: Linux(MIPS/ARM), Mac OS X, Android\n\n开发语言/Languages: C/C++, Python\n\n开发工具/Software & Tools:  Vim, GCC, GDB\n\n#PROFESSIONAL EXPERIENCE\n##2012/07 - Present\n\n###Hoge Software Co. Ltd. \n\n1. 职位/Title: \n\n    Lead Developer of C/C++ Department\n\n2. 职责/Responsible: \n\n\tLead of the C/C++ Department.\n\n\tDevelop framework and all basic modules of transcoding service for our M2O platform.\n\n\tDevelop live and VOD services based on nginx-rtmp-mod.\n\n\t公司目前主力产品为M2O新媒体服务平台，服务对象主要是致力于新媒体服务的各省市级电视台，在新媒体行业内产品占有率居前列。本人主要负责视频转码处理和流媒体相关的开发，处理的对象主要是MP4、TS、FLV封装的H.264和AAC数据以及HLS和RTMP流协议。\n\t\n\t完成了视频转码处理程序的主体框架（模块化分层结构）及主要功能模块的开发；\n\t\n\t完成了视频转码服务的视频入库转码，拆条，快编，多码流等功能开发；\n\t\n\t完成了针对RTMP和HLS协议，基于Nginx RTMP模块的二次开发。\n\n3. tags: \n\n\tnginx, ffmpeg, google-unittest, google-leveldb, boost\n\n##2011/05 - 2011/06\n###iSoftstone Co. Ltd. \n\n1. 职位/Title: \n\n\tEmbedded Developer of R&D Department\n\n2. 职责/Responsible:\n\n\tEmbedded software development based with Atheros and Realtech boards, hardware driver development excluded.\n\t\n\tNetwork analysis based on packet capturing.\n\t\n\tAndroid JNI development, mainly 802.11 analysis related.\n\t\n\t嵌入式平台的802.11数据抓取和数据挖掘相关开发，通过传感器（嵌入式设备）抓取周围的无线数据包，分析其IP层及以下的头信息，简单过滤后发往服务端做进一步数据挖掘。\n\t\n\t完成JNI层接口设计与实现；\n\t\n\t实现用于JNI和Java层数据传递的基于内存映射的环状缓冲区；\n\t\n\t完成数据包解析，包括物理层，MAC层，IP层包头和内容解析；\n\t\n\t项目需求分析；\n\t\n\t主体框架设计与开发；\n\t\n\t协议分析相关功能的开发；\n\n3. 目标平台/Platforms：\n\n\tAtheros、Realtech、Android Tablet\n\n#EDUCATION\n##Nanjing University of Post and Telecommunication\n2006 - 2010\n\nB.E. degree in network engineering\n\n\n#TRAINING\n##Cisco Certified Security Professional\n2008/07 - 2011/07\n","source":"_posts/2013-11-27-riders_resume.md","raw":"---\nlayout: post\ntitle: \"Rider's Resume\"\ndescription: \"My personal resume\"\ncategory: \ntags: [resume]\n---\n\n#SUMMARY OF QUALIFICATION\n3 year's working experience in C/C++ software development.\n\nExpertise in network analyzing, media transcoding, and media streaming.\n\nTeam work spirit. High liability and attribution. Be able to work under great pressure.\n\n3年C/C++开发经验，包括网络协议分析（OSI 3层及以下），数据包信息挖掘，媒体处理（MP4、TS、FLV、H.264、AAC），流媒体（RTMP/HLS）\n\n对软件开发充满热情，关注技术潮流\n\n对代码有洁癖，有不断优化代码的强迫症\n\n平台/Platforms: ARM, MIPS, x86\n\n操作系统/Operating Systems: Linux(MIPS/ARM), Mac OS X, Android\n\n开发语言/Languages: C/C++, Python\n\n开发工具/Software & Tools:  Vim, GCC, GDB\n\n#PROFESSIONAL EXPERIENCE\n##2012/07 - Present\n\n###Hoge Software Co. Ltd. \n\n1. 职位/Title: \n\n    Lead Developer of C/C++ Department\n\n2. 职责/Responsible: \n\n\tLead of the C/C++ Department.\n\n\tDevelop framework and all basic modules of transcoding service for our M2O platform.\n\n\tDevelop live and VOD services based on nginx-rtmp-mod.\n\n\t公司目前主力产品为M2O新媒体服务平台，服务对象主要是致力于新媒体服务的各省市级电视台，在新媒体行业内产品占有率居前列。本人主要负责视频转码处理和流媒体相关的开发，处理的对象主要是MP4、TS、FLV封装的H.264和AAC数据以及HLS和RTMP流协议。\n\t\n\t完成了视频转码处理程序的主体框架（模块化分层结构）及主要功能模块的开发；\n\t\n\t完成了视频转码服务的视频入库转码，拆条，快编，多码流等功能开发；\n\t\n\t完成了针对RTMP和HLS协议，基于Nginx RTMP模块的二次开发。\n\n3. tags: \n\n\tnginx, ffmpeg, google-unittest, google-leveldb, boost\n\n##2011/05 - 2011/06\n###iSoftstone Co. Ltd. \n\n1. 职位/Title: \n\n\tEmbedded Developer of R&D Department\n\n2. 职责/Responsible:\n\n\tEmbedded software development based with Atheros and Realtech boards, hardware driver development excluded.\n\t\n\tNetwork analysis based on packet capturing.\n\t\n\tAndroid JNI development, mainly 802.11 analysis related.\n\t\n\t嵌入式平台的802.11数据抓取和数据挖掘相关开发，通过传感器（嵌入式设备）抓取周围的无线数据包，分析其IP层及以下的头信息，简单过滤后发往服务端做进一步数据挖掘。\n\t\n\t完成JNI层接口设计与实现；\n\t\n\t实现用于JNI和Java层数据传递的基于内存映射的环状缓冲区；\n\t\n\t完成数据包解析，包括物理层，MAC层，IP层包头和内容解析；\n\t\n\t项目需求分析；\n\t\n\t主体框架设计与开发；\n\t\n\t协议分析相关功能的开发；\n\n3. 目标平台/Platforms：\n\n\tAtheros、Realtech、Android Tablet\n\n#EDUCATION\n##Nanjing University of Post and Telecommunication\n2006 - 2010\n\nB.E. degree in network engineering\n\n\n#TRAINING\n##Cisco Certified Security Professional\n2008/07 - 2011/07\n","slug":"riders_resume","published":1,"date":"2013-11-26T16:00:00.000Z","updated":"2018-03-07T06:11:13.309Z","comments":1,"photos":[],"link":"","_id":"cjegoturp0015i0fow6uhw73c","content":"<p>#SUMMARY OF QUALIFICATION<br>3 year’s working experience in C/C++ software development.</p>\n<p>Expertise in network analyzing, media transcoding, and media streaming.</p>\n<p>Team work spirit. High liability and attribution. Be able to work under great pressure.</p>\n<p>3年C/C++开发经验，包括网络协议分析（OSI 3层及以下），数据包信息挖掘，媒体处理（MP4、TS、FLV、H.264、AAC），流媒体（RTMP/HLS）</p>\n<p>对软件开发充满热情，关注技术潮流</p>\n<p>对代码有洁癖，有不断优化代码的强迫症</p>\n<p>平台/Platforms: ARM, MIPS, x86</p>\n<p>操作系统/Operating Systems: Linux(MIPS/ARM), Mac OS X, Android</p>\n<p>开发语言/Languages: C/C++, Python</p>\n<p>开发工具/Software &amp; Tools:  Vim, GCC, GDB</p>\n<p>#PROFESSIONAL EXPERIENCE</p>\n<p>##2012/07 - Present</p>\n<p>###Hoge Software Co. Ltd. </p>\n<ol>\n<li><p>职位/Title: </p>\n<p> Lead Developer of C/C++ Department</p>\n</li>\n<li><p>职责/Responsible: </p>\n<p> Lead of the C/C++ Department.</p>\n<p> Develop framework and all basic modules of transcoding service for our M2O platform.</p>\n<p> Develop live and VOD services based on nginx-rtmp-mod.</p>\n<p> 公司目前主力产品为M2O新媒体服务平台，服务对象主要是致力于新媒体服务的各省市级电视台，在新媒体行业内产品占有率居前列。本人主要负责视频转码处理和流媒体相关的开发，处理的对象主要是MP4、TS、FLV封装的H.264和AAC数据以及HLS和RTMP流协议。</p>\n<p> 完成了视频转码处理程序的主体框架（模块化分层结构）及主要功能模块的开发；</p>\n<p> 完成了视频转码服务的视频入库转码，拆条，快编，多码流等功能开发；</p>\n<p> 完成了针对RTMP和HLS协议，基于Nginx RTMP模块的二次开发。</p>\n</li>\n<li><p>tags: </p>\n<p> nginx, ffmpeg, google-unittest, google-leveldb, boost</p>\n</li>\n</ol>\n<p>##2011/05 - 2011/06</p>\n<p>###iSoftstone Co. Ltd. </p>\n<ol>\n<li><p>职位/Title: </p>\n<p> Embedded Developer of R&amp;D Department</p>\n</li>\n<li><p>职责/Responsible:</p>\n<p> Embedded software development based with Atheros and Realtech boards, hardware driver development excluded.</p>\n<p> Network analysis based on packet capturing.</p>\n<p> Android JNI development, mainly 802.11 analysis related.</p>\n<p> 嵌入式平台的802.11数据抓取和数据挖掘相关开发，通过传感器（嵌入式设备）抓取周围的无线数据包，分析其IP层及以下的头信息，简单过滤后发往服务端做进一步数据挖掘。</p>\n<p> 完成JNI层接口设计与实现；</p>\n<p> 实现用于JNI和Java层数据传递的基于内存映射的环状缓冲区；</p>\n<p> 完成数据包解析，包括物理层，MAC层，IP层包头和内容解析；</p>\n<p> 项目需求分析；</p>\n<p> 主体框架设计与开发；</p>\n<p> 协议分析相关功能的开发；</p>\n</li>\n<li><p>目标平台/Platforms：</p>\n<p> Atheros、Realtech、Android Tablet</p>\n</li>\n</ol>\n<p>#EDUCATION</p>\n<p>##Nanjing University of Post and Telecommunication<br>2006 - 2010</p>\n<p>B.E. degree in network engineering</p>\n<p>#TRAINING</p>\n<p>##Cisco Certified Security Professional<br>2008/07 - 2011/07</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#SUMMARY OF QUALIFICATION<br>3 year’s working experience in C/C++ software development.</p>\n<p>Expertise in network analyzing, media transcoding, and media streaming.</p>\n<p>Team work spirit. High liability and attribution. Be able to work under great pressure.</p>\n<p>3年C/C++开发经验，包括网络协议分析（OSI 3层及以下），数据包信息挖掘，媒体处理（MP4、TS、FLV、H.264、AAC），流媒体（RTMP/HLS）</p>\n<p>对软件开发充满热情，关注技术潮流</p>\n<p>对代码有洁癖，有不断优化代码的强迫症</p>\n<p>平台/Platforms: ARM, MIPS, x86</p>\n<p>操作系统/Operating Systems: Linux(MIPS/ARM), Mac OS X, Android</p>\n<p>开发语言/Languages: C/C++, Python</p>\n<p>开发工具/Software &amp; Tools:  Vim, GCC, GDB</p>\n<p>#PROFESSIONAL EXPERIENCE</p>\n<p>##2012/07 - Present</p>\n<p>###Hoge Software Co. Ltd. </p>\n<ol>\n<li><p>职位/Title: </p>\n<p> Lead Developer of C/C++ Department</p>\n</li>\n<li><p>职责/Responsible: </p>\n<p> Lead of the C/C++ Department.</p>\n<p> Develop framework and all basic modules of transcoding service for our M2O platform.</p>\n<p> Develop live and VOD services based on nginx-rtmp-mod.</p>\n<p> 公司目前主力产品为M2O新媒体服务平台，服务对象主要是致力于新媒体服务的各省市级电视台，在新媒体行业内产品占有率居前列。本人主要负责视频转码处理和流媒体相关的开发，处理的对象主要是MP4、TS、FLV封装的H.264和AAC数据以及HLS和RTMP流协议。</p>\n<p> 完成了视频转码处理程序的主体框架（模块化分层结构）及主要功能模块的开发；</p>\n<p> 完成了视频转码服务的视频入库转码，拆条，快编，多码流等功能开发；</p>\n<p> 完成了针对RTMP和HLS协议，基于Nginx RTMP模块的二次开发。</p>\n</li>\n<li><p>tags: </p>\n<p> nginx, ffmpeg, google-unittest, google-leveldb, boost</p>\n</li>\n</ol>\n<p>##2011/05 - 2011/06</p>\n<p>###iSoftstone Co. Ltd. </p>\n<ol>\n<li><p>职位/Title: </p>\n<p> Embedded Developer of R&amp;D Department</p>\n</li>\n<li><p>职责/Responsible:</p>\n<p> Embedded software development based with Atheros and Realtech boards, hardware driver development excluded.</p>\n<p> Network analysis based on packet capturing.</p>\n<p> Android JNI development, mainly 802.11 analysis related.</p>\n<p> 嵌入式平台的802.11数据抓取和数据挖掘相关开发，通过传感器（嵌入式设备）抓取周围的无线数据包，分析其IP层及以下的头信息，简单过滤后发往服务端做进一步数据挖掘。</p>\n<p> 完成JNI层接口设计与实现；</p>\n<p> 实现用于JNI和Java层数据传递的基于内存映射的环状缓冲区；</p>\n<p> 完成数据包解析，包括物理层，MAC层，IP层包头和内容解析；</p>\n<p> 项目需求分析；</p>\n<p> 主体框架设计与开发；</p>\n<p> 协议分析相关功能的开发；</p>\n</li>\n<li><p>目标平台/Platforms：</p>\n<p> Atheros、Realtech、Android Tablet</p>\n</li>\n</ol>\n<p>#EDUCATION</p>\n<p>##Nanjing University of Post and Telecommunication<br>2006 - 2010</p>\n<p>B.E. degree in network engineering</p>\n<p>#TRAINING</p>\n<p>##Cisco Certified Security Professional<br>2008/07 - 2011/07</p>\n"},{"layout":"post","title":"Errors running builder 'Android Pre Compiler' on project","description":"求人还是stackoverflow","category":null,"_content":"\n很久没用eclipse写android，今天想写个demo，先是启动是告诉我没有java 1.6，这个先不说，编译项目的时候居然报了如题错误。\n试了这个[方法](\nhttp://stackoverflow.com/questions/14455018/eclipse-android-errors-running-builder-android-pre-compiler-on-project)\n顺利解决。\n\n似乎是预编译器和.svn文件夹闹别扭，罢工了，过滤掉.svn文件夹就行了。\n\n这里顺便吐嘈下某些中文博客，原因讲不清楚就算了，给的解决方案也是够坑的。","source":"_posts/2015-04-01-android-pre-compiler-error.md","raw":"---\nlayout: post\ntitle: \"Errors running builder 'Android Pre Compiler' on project\"\ndescription: \"求人还是stackoverflow\"\ncategory: \ntags: [android, eclipse]\n---\n\n很久没用eclipse写android，今天想写个demo，先是启动是告诉我没有java 1.6，这个先不说，编译项目的时候居然报了如题错误。\n试了这个[方法](\nhttp://stackoverflow.com/questions/14455018/eclipse-android-errors-running-builder-android-pre-compiler-on-project)\n顺利解决。\n\n似乎是预编译器和.svn文件夹闹别扭，罢工了，过滤掉.svn文件夹就行了。\n\n这里顺便吐嘈下某些中文博客，原因讲不清楚就算了，给的解决方案也是够坑的。","slug":"android-pre-compiler-error","published":1,"date":"2015-03-31T16:00:00.000Z","updated":"2018-03-07T06:11:13.313Z","comments":1,"photos":[],"link":"","_id":"cjegoturq0016i0foaemlkyrm","content":"<p>很久没用eclipse写android，今天想写个demo，先是启动是告诉我没有java 1.6，这个先不说，编译项目的时候居然报了如题错误。<br>试了这个<a href=\"http://stackoverflow.com/questions/14455018/eclipse-android-errors-running-builder-android-pre-compiler-on-project\" target=\"_blank\" rel=\"noopener\">方法</a><br>顺利解决。</p>\n<p>似乎是预编译器和.svn文件夹闹别扭，罢工了，过滤掉.svn文件夹就行了。</p>\n<p>这里顺便吐嘈下某些中文博客，原因讲不清楚就算了，给的解决方案也是够坑的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很久没用eclipse写android，今天想写个demo，先是启动是告诉我没有java 1.6，这个先不说，编译项目的时候居然报了如题错误。<br>试了这个<a href=\"http://stackoverflow.com/questions/14455018/eclipse-android-errors-running-builder-android-pre-compiler-on-project\" target=\"_blank\" rel=\"noopener\">方法</a><br>顺利解决。</p>\n<p>似乎是预编译器和.svn文件夹闹别扭，罢工了，过滤掉.svn文件夹就行了。</p>\n<p>这里顺便吐嘈下某些中文博客，原因讲不清楚就算了，给的解决方案也是够坑的。</p>\n"},{"layout":"post","title":"Node's XAuth Support","description":"Node based XAuth client.","category":null,"_content":"\n[node-oauth](https://github.com/ciaranj/node-oauth)模块提供了OAuth和XAuth支持，根据[stackoverflow](http://stackoverflow.com/questions/7518795/instapaper-api-javascript-xauth/9645033#9645033)提供的信息，使用如下接口即可:\n\n    getOAuthRequestToken(extra_params, callback_function)\n其中extra_params:\n    \n    extra_params = {\n        \"x_auth_username\":\"__username__\",\n        \"x_auth_password\":\"__password__\",\n        \"x_auth_mode\":\"client_auth\"\n    }\n    \n饭否的XAuth实测可用。\n","source":"_posts/2013-11-27-xauth_with_node.md","raw":"---\nlayout: post\ntitle: \"Node's XAuth Support\"\ndescription: \"Node based XAuth client.\"\ncategory: \ntags: [node, xauth, fanfou]\n---\n\n[node-oauth](https://github.com/ciaranj/node-oauth)模块提供了OAuth和XAuth支持，根据[stackoverflow](http://stackoverflow.com/questions/7518795/instapaper-api-javascript-xauth/9645033#9645033)提供的信息，使用如下接口即可:\n\n    getOAuthRequestToken(extra_params, callback_function)\n其中extra_params:\n    \n    extra_params = {\n        \"x_auth_username\":\"__username__\",\n        \"x_auth_password\":\"__password__\",\n        \"x_auth_mode\":\"client_auth\"\n    }\n    \n饭否的XAuth实测可用。\n","slug":"xauth_with_node","published":1,"date":"2013-11-26T16:00:00.000Z","updated":"2018-03-07T06:11:13.310Z","comments":1,"photos":[],"link":"","_id":"cjegoturt0018i0foum9lyk80","content":"<p><a href=\"https://github.com/ciaranj/node-oauth\" target=\"_blank\" rel=\"noopener\">node-oauth</a>模块提供了OAuth和XAuth支持，根据<a href=\"http://stackoverflow.com/questions/7518795/instapaper-api-javascript-xauth/9645033#9645033\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>提供的信息，使用如下接口即可:</p>\n<pre><code>getOAuthRequestToken(extra_params, callback_function)\n</code></pre><p>其中extra_params:</p>\n<pre><code>extra_params = {\n    &quot;x_auth_username&quot;:&quot;__username__&quot;,\n    &quot;x_auth_password&quot;:&quot;__password__&quot;,\n    &quot;x_auth_mode&quot;:&quot;client_auth&quot;\n}\n</code></pre><p>饭否的XAuth实测可用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/ciaranj/node-oauth\" target=\"_blank\" rel=\"noopener\">node-oauth</a>模块提供了OAuth和XAuth支持，根据<a href=\"http://stackoverflow.com/questions/7518795/instapaper-api-javascript-xauth/9645033#9645033\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>提供的信息，使用如下接口即可:</p>\n<pre><code>getOAuthRequestToken(extra_params, callback_function)\n</code></pre><p>其中extra_params:</p>\n<pre><code>extra_params = {\n    &quot;x_auth_username&quot;:&quot;__username__&quot;,\n    &quot;x_auth_password&quot;:&quot;__password__&quot;,\n    &quot;x_auth_mode&quot;:&quot;client_auth&quot;\n}\n</code></pre><p>饭否的XAuth实测可用。</p>\n"},{"layout":"post","title":"MP4 to HLS based on nginx-http-mp4-module","tagline":null,"category":null,"published":1,"_content":"\n这里列出了我在基于nginx-http-mp4-module开发MP4直出HLS流时遇到的坑，哎，说多了都是泪啊……\n希望对你有帮助，如果你发现了一些没有列出来的问题，欢迎反馈，你知道怎么联系我的。\n\n\n* SPS和PPS何时发送？\n\n     IDR(nalu_type=5)之前发送\n\n* PMT和PAT如何构造？\n\n     PMT和PAT为固定字段，每ts发送一次即可。\n\n* 加入条带分割NAL头部对现有的H.264数据有何影响？\n\n     目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)\n\n* 码流和网络流形式的NAL在转换时需要注意哪些？\n\n     一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01\n\n* AAC头部是否需要修改？\n\n     AAC需要使用ADST封装\n\n* ADST包含哪些参数？从MP4文件的何box中读取参数？\n\n     profile: (object_type - 1)\n\n     sampling frequency: sample_rate_index\n\n     channel configuration: channels\n\n     通过mp4a->esds读取上述参数\n\n* 音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？\n\n     音频打包到一个PES再发送，大小为2930\n\n* 生成m3u8时如何分割？\n\n     以GOP为分割\n\n* aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？\n\n     aac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024\n\n* MP4中的elst atom应如何处理？\n\n     pts -= elst_start_time\n\n     dts -= elst_start_time\n\n     http://wiki.multimedia.cx/index.php?title=QuickTime_container#elst\n\n* WARNING: Unable to read video timestamps in track 1; this may be due to not having a key frame in this segment.\n\n     dts时间戳不为0即可，apple提供的切片工具(mediafilesegmenter)，使用的是10秒前缀;\n\n     某些安卓平台的播放器，不支持非0开始的流，比如UC，遨游和小米自带的浏览器等等，表现为播放视频时自动跳到10秒之后播放。\n\n* PAT中最重要的字段\n\n     PMT的PID，其他字段一般不变\n\n* PMT中最重要的字段\n\n     PID\n\n     PCR PID\n\n     音频类型\n\n     音频PID\n\n     视频类型\n\n     视频PID\n\n* PAT和PMT中的continuity counter是否需要递增？\n\n     建议连续，以兼容某些平台，比如安卓\n\n* 音、视频的continuity counter是否需要递增？\n\n     iOS平台和Mac平台的safari浏览器能够处理continuity counter跳跃，但是安卓的自带浏览器不行，如果安卓平台也在考虑范围内，最好安安分分的处理continuity counter","source":"_posts/2014-06-24-MP4-to-HLS-based-on-nginx-http-mp4-module.md","raw":"---\nlayout: post\ntitle: MP4 to HLS based on nginx-http-mp4-module\ntagline: null\ncategory: null\ntags: []\npublished: true\n---\n\n这里列出了我在基于nginx-http-mp4-module开发MP4直出HLS流时遇到的坑，哎，说多了都是泪啊……\n希望对你有帮助，如果你发现了一些没有列出来的问题，欢迎反馈，你知道怎么联系我的。\n\n\n* SPS和PPS何时发送？\n\n     IDR(nalu_type=5)之前发送\n\n* PMT和PAT如何构造？\n\n     PMT和PAT为固定字段，每ts发送一次即可。\n\n* 加入条带分割NAL头部对现有的H.264数据有何影响？\n\n     目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)\n\n* 码流和网络流形式的NAL在转换时需要注意哪些？\n\n     一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01\n\n* AAC头部是否需要修改？\n\n     AAC需要使用ADST封装\n\n* ADST包含哪些参数？从MP4文件的何box中读取参数？\n\n     profile: (object_type - 1)\n\n     sampling frequency: sample_rate_index\n\n     channel configuration: channels\n\n     通过mp4a->esds读取上述参数\n\n* 音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？\n\n     音频打包到一个PES再发送，大小为2930\n\n* 生成m3u8时如何分割？\n\n     以GOP为分割\n\n* aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？\n\n     aac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024\n\n* MP4中的elst atom应如何处理？\n\n     pts -= elst_start_time\n\n     dts -= elst_start_time\n\n     http://wiki.multimedia.cx/index.php?title=QuickTime_container#elst\n\n* WARNING: Unable to read video timestamps in track 1; this may be due to not having a key frame in this segment.\n\n     dts时间戳不为0即可，apple提供的切片工具(mediafilesegmenter)，使用的是10秒前缀;\n\n     某些安卓平台的播放器，不支持非0开始的流，比如UC，遨游和小米自带的浏览器等等，表现为播放视频时自动跳到10秒之后播放。\n\n* PAT中最重要的字段\n\n     PMT的PID，其他字段一般不变\n\n* PMT中最重要的字段\n\n     PID\n\n     PCR PID\n\n     音频类型\n\n     音频PID\n\n     视频类型\n\n     视频PID\n\n* PAT和PMT中的continuity counter是否需要递增？\n\n     建议连续，以兼容某些平台，比如安卓\n\n* 音、视频的continuity counter是否需要递增？\n\n     iOS平台和Mac平台的safari浏览器能够处理continuity counter跳跃，但是安卓的自带浏览器不行，如果安卓平台也在考虑范围内，最好安安分分的处理continuity counter","slug":"MP4-to-HLS-based-on-nginx-http-mp4-module","date":"2014-06-23T16:00:00.000Z","updated":"2018-03-07T06:11:13.312Z","comments":1,"photos":[],"link":"","_id":"cjegoturw001ai0foev9ybnna","content":"<p>这里列出了我在基于nginx-http-mp4-module开发MP4直出HLS流时遇到的坑，哎，说多了都是泪啊……<br>希望对你有帮助，如果你发现了一些没有列出来的问题，欢迎反馈，你知道怎么联系我的。</p>\n<ul>\n<li><p>SPS和PPS何时发送？</p>\n<p>   IDR(nalu_type=5)之前发送</p>\n</li>\n<li><p>PMT和PAT如何构造？</p>\n<p>   PMT和PAT为固定字段，每ts发送一次即可。</p>\n</li>\n<li><p>加入条带分割NAL头部对现有的H.264数据有何影响？</p>\n<p>   目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)</p>\n</li>\n<li><p>码流和网络流形式的NAL在转换时需要注意哪些？</p>\n<p>   一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01</p>\n</li>\n<li><p>AAC头部是否需要修改？</p>\n<p>   AAC需要使用ADST封装</p>\n</li>\n<li><p>ADST包含哪些参数？从MP4文件的何box中读取参数？</p>\n<p>   profile: (object_type - 1)</p>\n<p>   sampling frequency: sample_rate_index</p>\n<p>   channel configuration: channels</p>\n<p>   通过mp4a-&gt;esds读取上述参数</p>\n</li>\n<li><p>音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？</p>\n<p>   音频打包到一个PES再发送，大小为2930</p>\n</li>\n<li><p>生成m3u8时如何分割？</p>\n<p>   以GOP为分割</p>\n</li>\n<li><p>aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？</p>\n<p>   aac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024</p>\n</li>\n<li><p>MP4中的elst atom应如何处理？</p>\n<p>   pts -= elst_start_time</p>\n<p>   dts -= elst_start_time</p>\n<p>   <a href=\"http://wiki.multimedia.cx/index.php?title=QuickTime_container#elst\" target=\"_blank\" rel=\"noopener\">http://wiki.multimedia.cx/index.php?title=QuickTime_container#elst</a></p>\n</li>\n<li><p>WARNING: Unable to read video timestamps in track 1; this may be due to not having a key frame in this segment.</p>\n<p>   dts时间戳不为0即可，apple提供的切片工具(mediafilesegmenter)，使用的是10秒前缀;</p>\n<p>   某些安卓平台的播放器，不支持非0开始的流，比如UC，遨游和小米自带的浏览器等等，表现为播放视频时自动跳到10秒之后播放。</p>\n</li>\n<li><p>PAT中最重要的字段</p>\n<p>   PMT的PID，其他字段一般不变</p>\n</li>\n<li><p>PMT中最重要的字段</p>\n<p>   PID</p>\n<p>   PCR PID</p>\n<p>   音频类型</p>\n<p>   音频PID</p>\n<p>   视频类型</p>\n<p>   视频PID</p>\n</li>\n<li><p>PAT和PMT中的continuity counter是否需要递增？</p>\n<p>   建议连续，以兼容某些平台，比如安卓</p>\n</li>\n<li><p>音、视频的continuity counter是否需要递增？</p>\n<p>   iOS平台和Mac平台的safari浏览器能够处理continuity counter跳跃，但是安卓的自带浏览器不行，如果安卓平台也在考虑范围内，最好安安分分的处理continuity counter</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>这里列出了我在基于nginx-http-mp4-module开发MP4直出HLS流时遇到的坑，哎，说多了都是泪啊……<br>希望对你有帮助，如果你发现了一些没有列出来的问题，欢迎反馈，你知道怎么联系我的。</p>\n<ul>\n<li><p>SPS和PPS何时发送？</p>\n<p>   IDR(nalu_type=5)之前发送</p>\n</li>\n<li><p>PMT和PAT如何构造？</p>\n<p>   PMT和PAT为固定字段，每ts发送一次即可。</p>\n</li>\n<li><p>加入条带分割NAL头部对现有的H.264数据有何影响？</p>\n<p>   目前看无影响，每一sample前发送条带分割NAL(nalu_type=9)</p>\n</li>\n<li><p>码流和网络流形式的NAL在转换时需要注意哪些？</p>\n<p>   一般情况下发送0x00 00 00 01，仅在sample的非首slice时发送0x00 00 01</p>\n</li>\n<li><p>AAC头部是否需要修改？</p>\n<p>   AAC需要使用ADST封装</p>\n</li>\n<li><p>ADST包含哪些参数？从MP4文件的何box中读取参数？</p>\n<p>   profile: (object_type - 1)</p>\n<p>   sampling frequency: sample_rate_index</p>\n<p>   channel configuration: channels</p>\n<p>   通过mp4a-&gt;esds读取上述参数</p>\n</li>\n<li><p>音频数据如何汇总成一个PES包再发送，而不是每一个sample封装一个PES？</p>\n<p>   音频打包到一个PES再发送，大小为2930</p>\n</li>\n<li><p>生成m3u8时如何分割？</p>\n<p>   以GOP为分割</p>\n</li>\n<li><p>aac的duration为什么固定是1024？遇到非固定duration的aac应如何处理？</p>\n<p>   aac规定每个frame包含1024个samples；忽略stts中的delta，固定输出1024</p>\n</li>\n<li><p>MP4中的elst atom应如何处理？</p>\n<p>   pts -= elst_start_time</p>\n<p>   dts -= elst_start_time</p>\n<p>   <a href=\"http://wiki.multimedia.cx/index.php?title=QuickTime_container#elst\" target=\"_blank\" rel=\"noopener\">http://wiki.multimedia.cx/index.php?title=QuickTime_container#elst</a></p>\n</li>\n<li><p>WARNING: Unable to read video timestamps in track 1; this may be due to not having a key frame in this segment.</p>\n<p>   dts时间戳不为0即可，apple提供的切片工具(mediafilesegmenter)，使用的是10秒前缀;</p>\n<p>   某些安卓平台的播放器，不支持非0开始的流，比如UC，遨游和小米自带的浏览器等等，表现为播放视频时自动跳到10秒之后播放。</p>\n</li>\n<li><p>PAT中最重要的字段</p>\n<p>   PMT的PID，其他字段一般不变</p>\n</li>\n<li><p>PMT中最重要的字段</p>\n<p>   PID</p>\n<p>   PCR PID</p>\n<p>   音频类型</p>\n<p>   音频PID</p>\n<p>   视频类型</p>\n<p>   视频PID</p>\n</li>\n<li><p>PAT和PMT中的continuity counter是否需要递增？</p>\n<p>   建议连续，以兼容某些平台，比如安卓</p>\n</li>\n<li><p>音、视频的continuity counter是否需要递增？</p>\n<p>   iOS平台和Mac平台的safari浏览器能够处理continuity counter跳跃，但是安卓的自带浏览器不行，如果安卓平台也在考虑范围内，最好安安分分的处理continuity counter</p>\n</li>\n</ul>\n"},{"layout":"post","title":"C++ cast备忘","description":"C++ cast备忘","category":null,"_content":"1. 这格式见了鬼了，表格出不来，懒得找原因了。\n2. 从boost-1.53.0开始，shared_polymorphic_cast和shared_polymorphic_downcast被删除，分别变为polymorphic_pointer_cast和polymorphic_pointer_downcast。（没有向前兼容这种事情实在……）\n\n\n|名称|介绍|\n|---|---|\n|upcast|从派生到基类|\n|downcast|从基类到派生|\n\n\n|名称|介绍|\n|---|---|\n|dynamic_cast|upcast and downcast with target type check|\n|static_cast|upcast and downcast without target type check|\n|reinterpret_cast|all kinds cast without target type check|\n|boost::static_pointer_cast|作用范围同static_cast，用于智能指针的类型转换，同时处理引用计数|\n|boost::dynamic_pointer_cast|作用范围同dynamic_cast，用于智能指针的类型转换，同时处理引用计数|\n|boost::reinterpret_pointer_cast|作用范围同reinterpret_cast，用于智能指针的类型转换，同时处理引用计数|\n|boost::shared_polymorphic_downcast/boost::polymorphic_pointer_downcast|作用范围同static_cast，在定义NDEBUG时，使用dynamic做运行时检测，未定义NDEBUG时，同static_cast，用于智能指针的类型转换，同时处理引用计数|\n|boost::shared_polymorphic_cast/boost::polymorphic_pointer_cast:|作用范围同dynamic_cast，类型转换失败时抛出异常，用于智能指针的类型转换，同时处理引用计数|\n|boost::polymorphic_cast|作用范围同dynamic_cast，类型转换失败时抛出异常，用于非智能指针的类型转换|\n|boost::polymorphic_downcast|作用范围同static_cast，未定义NDEBUG时，同static_cast，用于智能指针的类型转换，同时处理引用计数，用于非智能指针的类型转换|\n","source":"_posts/2015-12-22-cpp-cast.md","raw":"---\nlayout: post\ntitle: \"C++ cast备忘\"\ndescription: \"C++ cast备忘\"\ncategory:\ntags: [c++]\n---\n1. 这格式见了鬼了，表格出不来，懒得找原因了。\n2. 从boost-1.53.0开始，shared_polymorphic_cast和shared_polymorphic_downcast被删除，分别变为polymorphic_pointer_cast和polymorphic_pointer_downcast。（没有向前兼容这种事情实在……）\n\n\n|名称|介绍|\n|---|---|\n|upcast|从派生到基类|\n|downcast|从基类到派生|\n\n\n|名称|介绍|\n|---|---|\n|dynamic_cast|upcast and downcast with target type check|\n|static_cast|upcast and downcast without target type check|\n|reinterpret_cast|all kinds cast without target type check|\n|boost::static_pointer_cast|作用范围同static_cast，用于智能指针的类型转换，同时处理引用计数|\n|boost::dynamic_pointer_cast|作用范围同dynamic_cast，用于智能指针的类型转换，同时处理引用计数|\n|boost::reinterpret_pointer_cast|作用范围同reinterpret_cast，用于智能指针的类型转换，同时处理引用计数|\n|boost::shared_polymorphic_downcast/boost::polymorphic_pointer_downcast|作用范围同static_cast，在定义NDEBUG时，使用dynamic做运行时检测，未定义NDEBUG时，同static_cast，用于智能指针的类型转换，同时处理引用计数|\n|boost::shared_polymorphic_cast/boost::polymorphic_pointer_cast:|作用范围同dynamic_cast，类型转换失败时抛出异常，用于智能指针的类型转换，同时处理引用计数|\n|boost::polymorphic_cast|作用范围同dynamic_cast，类型转换失败时抛出异常，用于非智能指针的类型转换|\n|boost::polymorphic_downcast|作用范围同static_cast，未定义NDEBUG时，同static_cast，用于智能指针的类型转换，同时处理引用计数，用于非智能指针的类型转换|\n","slug":"cpp-cast","published":1,"date":"2015-12-21T16:00:00.000Z","updated":"2018-03-07T06:11:13.313Z","comments":1,"photos":[],"link":"","_id":"cjegoturz001di0fo0bcplcas","content":"<ol>\n<li>这格式见了鬼了，表格出不来，懒得找原因了。</li>\n<li>从boost-1.53.0开始，shared_polymorphic_cast和shared_polymorphic_downcast被删除，分别变为polymorphic_pointer_cast和polymorphic_pointer_downcast。（没有向前兼容这种事情实在……）</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>upcast</td>\n<td>从派生到基类</td>\n</tr>\n<tr>\n<td>downcast</td>\n<td>从基类到派生</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dynamic_cast</td>\n<td>upcast and downcast with target type check</td>\n</tr>\n<tr>\n<td>static_cast</td>\n<td>upcast and downcast without target type check</td>\n</tr>\n<tr>\n<td>reinterpret_cast</td>\n<td>all kinds cast without target type check</td>\n</tr>\n<tr>\n<td>boost::static_pointer_cast</td>\n<td>作用范围同static_cast，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::dynamic_pointer_cast</td>\n<td>作用范围同dynamic_cast，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::reinterpret_pointer_cast</td>\n<td>作用范围同reinterpret_cast，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::shared_polymorphic_downcast/boost::polymorphic_pointer_downcast</td>\n<td>作用范围同static_cast，在定义NDEBUG时，使用dynamic做运行时检测，未定义NDEBUG时，同static_cast，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::shared_polymorphic_cast/boost::polymorphic_pointer_cast:</td>\n<td>作用范围同dynamic_cast，类型转换失败时抛出异常，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::polymorphic_cast</td>\n<td>作用范围同dynamic_cast，类型转换失败时抛出异常，用于非智能指针的类型转换</td>\n</tr>\n<tr>\n<td>boost::polymorphic_downcast</td>\n<td>作用范围同static_cast，未定义NDEBUG时，同static_cast，用于智能指针的类型转换，同时处理引用计数，用于非智能指针的类型转换</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>这格式见了鬼了，表格出不来，懒得找原因了。</li>\n<li>从boost-1.53.0开始，shared_polymorphic_cast和shared_polymorphic_downcast被删除，分别变为polymorphic_pointer_cast和polymorphic_pointer_downcast。（没有向前兼容这种事情实在……）</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>upcast</td>\n<td>从派生到基类</td>\n</tr>\n<tr>\n<td>downcast</td>\n<td>从基类到派生</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dynamic_cast</td>\n<td>upcast and downcast with target type check</td>\n</tr>\n<tr>\n<td>static_cast</td>\n<td>upcast and downcast without target type check</td>\n</tr>\n<tr>\n<td>reinterpret_cast</td>\n<td>all kinds cast without target type check</td>\n</tr>\n<tr>\n<td>boost::static_pointer_cast</td>\n<td>作用范围同static_cast，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::dynamic_pointer_cast</td>\n<td>作用范围同dynamic_cast，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::reinterpret_pointer_cast</td>\n<td>作用范围同reinterpret_cast，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::shared_polymorphic_downcast/boost::polymorphic_pointer_downcast</td>\n<td>作用范围同static_cast，在定义NDEBUG时，使用dynamic做运行时检测，未定义NDEBUG时，同static_cast，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::shared_polymorphic_cast/boost::polymorphic_pointer_cast:</td>\n<td>作用范围同dynamic_cast，类型转换失败时抛出异常，用于智能指针的类型转换，同时处理引用计数</td>\n</tr>\n<tr>\n<td>boost::polymorphic_cast</td>\n<td>作用范围同dynamic_cast，类型转换失败时抛出异常，用于非智能指针的类型转换</td>\n</tr>\n<tr>\n<td>boost::polymorphic_downcast</td>\n<td>作用范围同static_cast，未定义NDEBUG时，同static_cast，用于智能指针的类型转换，同时处理引用计数，用于非智能指针的类型转换</td>\n</tr>\n</tbody>\n</table>\n"},{"layout":"post","title":"HTTP Live Streaming 笔记","tagline":"","category":null,"published":1,"_content":"# Playlist\n\n* m3u8：扩展的M3U文件，以行分割，每一行结尾是LF或者CR LF。每一行表示一个URI，空行（被忽略）或者以#开头（注释或者tag/标签）。不能包含空格（？）。\n* URI：表示一个分片或者一个playlist文件。可能是相对路径，若是，则根据该playlist路径拼凑完整路径。\n* Media Playlist：仅包含分片的palylist\n* Master Playlist：仅包含playlist的playlist\n* Tags：以#EXT开头，所有其他的以#开头的行均是注释。\n* duartion：所有分片duration之和\n* 编码：HTTP Content-Type \"application/vnd.apple.mpegurl\"的m3u8文件为UTF-8编码，HTTP Content-Type \"audio/mpegurl\"的m3u文件为US-ASCII编码\n\n* AttributeName=AttributeValue,AttributeName=AttributeValue,…\n\n\tAttributeName不能包含空格，只能由A～Z和\"-\"组成，同一个AttributeName在一个attribute list中不能重复。\n\tAttributeValue只能是10进制数字，十六进制数字(0x/0X)，十进制浮点数，引号包裹的字符串（“），没有引号包裹的可枚举字符串（？），十进制分辨率(widthxheight)\n\n## EXTM3U\n区分M3U8和M8U文件的标签\n\n## EXTINF\n标识分片的duration，格式：\n\n    #EXTINF:<duration>,<value>\n\nduration是十进制数字或者十进制浮点数，单位为秒，协议版本号低于3的仅使用十进制证书\nvalue可选\n\n## EXT-X-BYTERANGE:\\<n>[@o]\n表示sub-range of resource\nn表示sub-range长度，单位为字节\no是一个十进制整数，标识sub-range的起始位置，从resource的开始位置的偏移量，单位为字节\n协议版本号从4开始使用该标签\n\n## EXT-X-TARGETDURATION:\\<s>\n表示playlist文件中可能出现的最大duration\ns是最大duration，以秒为单位\n\n## EXT-X-MEDIA-SEQUENCE:\\<number>\n标识playlist文件中出现的第一个sequence number，仅出现一次\n\n## EXT-X-KEY:<attribute-list>\n作用域到下一个包含相同KEYFORMAT attribute的EXT-X-KEY标签之前\nMETHOD：NONE, AES-128, SAMPLE-AES，若为NONE，则必须包含URI,VI,KEYFORMAT,KEYFORMATVERSIONS；若为AES-128，则必须包含URI，可选VI；若为SAMPLE-AES，可选VI\nURI：key的URI\nIV：Initialization Vector，十六进制整数，协议从版本号2开始包含此变量\nKEYFORMAT：引用字符串\nKEYFORMATVERSIONS：引用字符串，出现在协议版本号5中\n\n## EXT-X-PROGRAM-DATE-TIME:<YYYY-MM-DDThh:mm:ssZ>\n接下来的第一个的分片时间\n\n## EXT-X-ALLOW-CACHE:<YES|NO>\n客户端是否可以缓存分片用于回放，仅能出现一次\n\n## EXT-X-PLAYLIST-TYPE:<EVENT|VOD>\nplaylist是否可修改\n\n## EXT-X-ENDLIST\n表示不再有分片，仅能出现一次\n\n## EXT-X-MEDIA:<attribute-list>\n用于表示同一内容的不同选择(alternative reditions)，比如只包含音频的英语，法语和西班牙语音轨，或者仅包含视频的两个摄像机机位，format相同\nURI可选\nTYPE三选一，VIDEO/AUDIO/SUBTITLES，同一GROUP的必须相同\nGROUP-ID引用字符串\nLANGUAGE可选 引用字符串，参考RFC 5646，若AUTOSELECT为YES，则LANGUAGE必须有效\nNAME引用字符串，同一GROUP的必须不同\nDEFAULT二选一YES/NO，同一GROUP仅有一个为YES\nAUTOSELECT二选一YES/NO\nFORCED二选一YES/NO 可选\nCHARACTERISTICS引用字符串 可选\n\n## EXT-X-STREAM-INF:<attribute-list>\\<URI>\n表示URI为playlist\nBANDWIDTH必须包含，十进制整数，单位为比特\nPROGRAM-ID Master Playlist中通过不同的PROGRAM-ID表示相同presentation的不同编码\nCODECS引用字符串，value通过逗号分割，建议包含\nRESOLUTION 视频分辨率\nAUDIO 引用字符串，和GROUP-ID相同\nVIDEO 引用字符串，和GROUP-ID相同\nSUBTITLES 引用字符串，和GROUP-ID相同\n\n## EXT-X-DISCONTUNUITY\n媒体信息发生变化，媒体信息包括文件格式，tracks的数量和类型，编码参数，编码顺序(encoding sequence)，时间戳顺序(timestamp sequence)\n\n## EXT-X-I-FRAMES-ONLY\n表示分片只包含I帧，协议从版本号4开始包含此标签\n\n## EXT-X-MAP:<attribute-list>\n标识如何获取分片的PAT/PMT，对该标签之后的分片有效\n仅和EXT-X-I-FRAMES-ONLY一起出现，建议只用在没有PAT/PMT开头的分片\n协议从版本号5开始使用该标签\nURI引用字符串\nBYTERANGE引用字符串\n\n## EXT-X-I-FRAME-STREAM-INF:<attribute-list>\n表示I帧列表\nURI\nBANDWIDTH\n\n## EXT-X-VERSION:<n>\n协议版本号\n\n# 额外的注意：\n\n1. media segment：分片\n2. 编码 MPEG-2 Transport Stream/MPEG audio elementary stream/WebVTT（字幕）\n3. TS分片必须仅包含一个MPEG-2 Program。每一个TS分片都应当以PAT和PMT开头。视频分片必须包含一个I帧（完整GOP？）\n5. TS或者audio elementacontentry stream分片必须保证sequence number连续，时间戳连续，除非是第一个分片或者出现了EXT-X-DISCONTINUITY标签。\n","source":"_posts/2014-06-24-HTTP-Live-Streaming-notes.md","raw":"---\nlayout: post\ntitle: HTTP Live Streaming 笔记\ntagline: \"\"\ncategory: null\ntags: []\npublished: true\n---\n# Playlist\n\n* m3u8：扩展的M3U文件，以行分割，每一行结尾是LF或者CR LF。每一行表示一个URI，空行（被忽略）或者以#开头（注释或者tag/标签）。不能包含空格（？）。\n* URI：表示一个分片或者一个playlist文件。可能是相对路径，若是，则根据该playlist路径拼凑完整路径。\n* Media Playlist：仅包含分片的palylist\n* Master Playlist：仅包含playlist的playlist\n* Tags：以#EXT开头，所有其他的以#开头的行均是注释。\n* duartion：所有分片duration之和\n* 编码：HTTP Content-Type \"application/vnd.apple.mpegurl\"的m3u8文件为UTF-8编码，HTTP Content-Type \"audio/mpegurl\"的m3u文件为US-ASCII编码\n\n* AttributeName=AttributeValue,AttributeName=AttributeValue,…\n\n\tAttributeName不能包含空格，只能由A～Z和\"-\"组成，同一个AttributeName在一个attribute list中不能重复。\n\tAttributeValue只能是10进制数字，十六进制数字(0x/0X)，十进制浮点数，引号包裹的字符串（“），没有引号包裹的可枚举字符串（？），十进制分辨率(widthxheight)\n\n## EXTM3U\n区分M3U8和M8U文件的标签\n\n## EXTINF\n标识分片的duration，格式：\n\n    #EXTINF:<duration>,<value>\n\nduration是十进制数字或者十进制浮点数，单位为秒，协议版本号低于3的仅使用十进制证书\nvalue可选\n\n## EXT-X-BYTERANGE:\\<n>[@o]\n表示sub-range of resource\nn表示sub-range长度，单位为字节\no是一个十进制整数，标识sub-range的起始位置，从resource的开始位置的偏移量，单位为字节\n协议版本号从4开始使用该标签\n\n## EXT-X-TARGETDURATION:\\<s>\n表示playlist文件中可能出现的最大duration\ns是最大duration，以秒为单位\n\n## EXT-X-MEDIA-SEQUENCE:\\<number>\n标识playlist文件中出现的第一个sequence number，仅出现一次\n\n## EXT-X-KEY:<attribute-list>\n作用域到下一个包含相同KEYFORMAT attribute的EXT-X-KEY标签之前\nMETHOD：NONE, AES-128, SAMPLE-AES，若为NONE，则必须包含URI,VI,KEYFORMAT,KEYFORMATVERSIONS；若为AES-128，则必须包含URI，可选VI；若为SAMPLE-AES，可选VI\nURI：key的URI\nIV：Initialization Vector，十六进制整数，协议从版本号2开始包含此变量\nKEYFORMAT：引用字符串\nKEYFORMATVERSIONS：引用字符串，出现在协议版本号5中\n\n## EXT-X-PROGRAM-DATE-TIME:<YYYY-MM-DDThh:mm:ssZ>\n接下来的第一个的分片时间\n\n## EXT-X-ALLOW-CACHE:<YES|NO>\n客户端是否可以缓存分片用于回放，仅能出现一次\n\n## EXT-X-PLAYLIST-TYPE:<EVENT|VOD>\nplaylist是否可修改\n\n## EXT-X-ENDLIST\n表示不再有分片，仅能出现一次\n\n## EXT-X-MEDIA:<attribute-list>\n用于表示同一内容的不同选择(alternative reditions)，比如只包含音频的英语，法语和西班牙语音轨，或者仅包含视频的两个摄像机机位，format相同\nURI可选\nTYPE三选一，VIDEO/AUDIO/SUBTITLES，同一GROUP的必须相同\nGROUP-ID引用字符串\nLANGUAGE可选 引用字符串，参考RFC 5646，若AUTOSELECT为YES，则LANGUAGE必须有效\nNAME引用字符串，同一GROUP的必须不同\nDEFAULT二选一YES/NO，同一GROUP仅有一个为YES\nAUTOSELECT二选一YES/NO\nFORCED二选一YES/NO 可选\nCHARACTERISTICS引用字符串 可选\n\n## EXT-X-STREAM-INF:<attribute-list>\\<URI>\n表示URI为playlist\nBANDWIDTH必须包含，十进制整数，单位为比特\nPROGRAM-ID Master Playlist中通过不同的PROGRAM-ID表示相同presentation的不同编码\nCODECS引用字符串，value通过逗号分割，建议包含\nRESOLUTION 视频分辨率\nAUDIO 引用字符串，和GROUP-ID相同\nVIDEO 引用字符串，和GROUP-ID相同\nSUBTITLES 引用字符串，和GROUP-ID相同\n\n## EXT-X-DISCONTUNUITY\n媒体信息发生变化，媒体信息包括文件格式，tracks的数量和类型，编码参数，编码顺序(encoding sequence)，时间戳顺序(timestamp sequence)\n\n## EXT-X-I-FRAMES-ONLY\n表示分片只包含I帧，协议从版本号4开始包含此标签\n\n## EXT-X-MAP:<attribute-list>\n标识如何获取分片的PAT/PMT，对该标签之后的分片有效\n仅和EXT-X-I-FRAMES-ONLY一起出现，建议只用在没有PAT/PMT开头的分片\n协议从版本号5开始使用该标签\nURI引用字符串\nBYTERANGE引用字符串\n\n## EXT-X-I-FRAME-STREAM-INF:<attribute-list>\n表示I帧列表\nURI\nBANDWIDTH\n\n## EXT-X-VERSION:<n>\n协议版本号\n\n# 额外的注意：\n\n1. media segment：分片\n2. 编码 MPEG-2 Transport Stream/MPEG audio elementary stream/WebVTT（字幕）\n3. TS分片必须仅包含一个MPEG-2 Program。每一个TS分片都应当以PAT和PMT开头。视频分片必须包含一个I帧（完整GOP？）\n5. TS或者audio elementacontentry stream分片必须保证sequence number连续，时间戳连续，除非是第一个分片或者出现了EXT-X-DISCONTINUITY标签。\n","slug":"HTTP-Live-Streaming-notes","date":"2014-06-23T16:00:00.000Z","updated":"2018-03-07T06:11:13.311Z","comments":1,"photos":[],"link":"","_id":"cjegotus1001fi0fo2987n6f8","content":"<h1 id=\"Playlist\"><a href=\"#Playlist\" class=\"headerlink\" title=\"Playlist\"></a>Playlist</h1><ul>\n<li>m3u8：扩展的M3U文件，以行分割，每一行结尾是LF或者CR LF。每一行表示一个URI，空行（被忽略）或者以#开头（注释或者tag/标签）。不能包含空格（？）。</li>\n<li>URI：表示一个分片或者一个playlist文件。可能是相对路径，若是，则根据该playlist路径拼凑完整路径。</li>\n<li>Media Playlist：仅包含分片的palylist</li>\n<li>Master Playlist：仅包含playlist的playlist</li>\n<li>Tags：以#EXT开头，所有其他的以#开头的行均是注释。</li>\n<li>duartion：所有分片duration之和</li>\n<li><p>编码：HTTP Content-Type “application/vnd.apple.mpegurl”的m3u8文件为UTF-8编码，HTTP Content-Type “audio/mpegurl”的m3u文件为US-ASCII编码</p>\n</li>\n<li><p>AttributeName=AttributeValue,AttributeName=AttributeValue,…</p>\n<p>  AttributeName不能包含空格，只能由A～Z和”-“组成，同一个AttributeName在一个attribute list中不能重复。<br>  AttributeValue只能是10进制数字，十六进制数字(0x/0X)，十进制浮点数，引号包裹的字符串（“），没有引号包裹的可枚举字符串（？），十进制分辨率(widthxheight)</p>\n</li>\n</ul>\n<h2 id=\"EXTM3U\"><a href=\"#EXTM3U\" class=\"headerlink\" title=\"EXTM3U\"></a>EXTM3U</h2><p>区分M3U8和M8U文件的标签</p>\n<h2 id=\"EXTINF\"><a href=\"#EXTINF\" class=\"headerlink\" title=\"EXTINF\"></a>EXTINF</h2><p>标识分片的duration，格式：</p>\n<pre><code>#EXTINF:&lt;duration&gt;,&lt;value&gt;\n</code></pre><p>duration是十进制数字或者十进制浮点数，单位为秒，协议版本号低于3的仅使用十进制证书<br>value可选</p>\n<h2 id=\"EXT-X-BYTERANGE-o\"><a href=\"#EXT-X-BYTERANGE-o\" class=\"headerlink\" title=\"EXT-X-BYTERANGE:\\[@o]\"></a>EXT-X-BYTERANGE:\\<n>[@o]</n></h2><p>表示sub-range of resource<br>n表示sub-range长度，单位为字节<br>o是一个十进制整数，标识sub-range的起始位置，从resource的开始位置的偏移量，单位为字节<br>协议版本号从4开始使用该标签</p>\n<h2 id=\"EXT-X-TARGETDURATION\"><a href=\"#EXT-X-TARGETDURATION\" class=\"headerlink\" title=\"EXT-X-TARGETDURATION:\\\"></a>EXT-X-TARGETDURATION:\\<s></s></h2><p>表示playlist文件中可能出现的最大duration<br>s是最大duration，以秒为单位</p>\n<h2 id=\"EXT-X-MEDIA-SEQUENCE\"><a href=\"#EXT-X-MEDIA-SEQUENCE\" class=\"headerlink\" title=\"EXT-X-MEDIA-SEQUENCE:\\\"></a>EXT-X-MEDIA-SEQUENCE:\\<number></number></h2><p>标识playlist文件中出现的第一个sequence number，仅出现一次</p>\n<h2 id=\"EXT-X-KEY\"><a href=\"#EXT-X-KEY\" class=\"headerlink\" title=\"EXT-X-KEY:\"></a>EXT-X-KEY:<attribute-list></attribute-list></h2><p>作用域到下一个包含相同KEYFORMAT attribute的EXT-X-KEY标签之前<br>METHOD：NONE, AES-128, SAMPLE-AES，若为NONE，则必须包含URI,VI,KEYFORMAT,KEYFORMATVERSIONS；若为AES-128，则必须包含URI，可选VI；若为SAMPLE-AES，可选VI<br>URI：key的URI<br>IV：Initialization Vector，十六进制整数，协议从版本号2开始包含此变量<br>KEYFORMAT：引用字符串<br>KEYFORMATVERSIONS：引用字符串，出现在协议版本号5中</p>\n<h2 id=\"EXT-X-PROGRAM-DATE-TIME-YYYY-MM-DDThh-mm-ssZ\"><a href=\"#EXT-X-PROGRAM-DATE-TIME-YYYY-MM-DDThh-mm-ssZ\" class=\"headerlink\" title=\"EXT-X-PROGRAM-DATE-TIME:YYYY-MM-DDThh:mm:ssZ\"></a>EXT-X-PROGRAM-DATE-TIME:<a href=\"YYYY-MM-DDThh:mm:ssZ\" target=\"_blank\" rel=\"noopener\">YYYY-MM-DDThh:mm:ssZ</a></h2><p>接下来的第一个的分片时间</p>\n<h2 id=\"EXT-X-ALLOW-CACHE-lt-YES-NO-gt\"><a href=\"#EXT-X-ALLOW-CACHE-lt-YES-NO-gt\" class=\"headerlink\" title=\"EXT-X-ALLOW-CACHE:&lt;YES|NO&gt;\"></a>EXT-X-ALLOW-CACHE:&lt;YES|NO&gt;</h2><p>客户端是否可以缓存分片用于回放，仅能出现一次</p>\n<h2 id=\"EXT-X-PLAYLIST-TYPE-lt-EVENT-VOD-gt\"><a href=\"#EXT-X-PLAYLIST-TYPE-lt-EVENT-VOD-gt\" class=\"headerlink\" title=\"EXT-X-PLAYLIST-TYPE:&lt;EVENT|VOD&gt;\"></a>EXT-X-PLAYLIST-TYPE:&lt;EVENT|VOD&gt;</h2><p>playlist是否可修改</p>\n<h2 id=\"EXT-X-ENDLIST\"><a href=\"#EXT-X-ENDLIST\" class=\"headerlink\" title=\"EXT-X-ENDLIST\"></a>EXT-X-ENDLIST</h2><p>表示不再有分片，仅能出现一次</p>\n<h2 id=\"EXT-X-MEDIA\"><a href=\"#EXT-X-MEDIA\" class=\"headerlink\" title=\"EXT-X-MEDIA:\"></a>EXT-X-MEDIA:<attribute-list></attribute-list></h2><p>用于表示同一内容的不同选择(alternative reditions)，比如只包含音频的英语，法语和西班牙语音轨，或者仅包含视频的两个摄像机机位，format相同<br>URI可选<br>TYPE三选一，VIDEO/AUDIO/SUBTITLES，同一GROUP的必须相同<br>GROUP-ID引用字符串<br>LANGUAGE可选 引用字符串，参考RFC 5646，若AUTOSELECT为YES，则LANGUAGE必须有效<br>NAME引用字符串，同一GROUP的必须不同<br>DEFAULT二选一YES/NO，同一GROUP仅有一个为YES<br>AUTOSELECT二选一YES/NO<br>FORCED二选一YES/NO 可选<br>CHARACTERISTICS引用字符串 可选</p>\n<h2 id=\"EXT-X-STREAM-INF\"><a href=\"#EXT-X-STREAM-INF\" class=\"headerlink\" title=\"EXT-X-STREAM-INF:\\\"></a>EXT-X-STREAM-INF:<attribute-list>\\<uri></uri></attribute-list></h2><p>表示URI为playlist<br>BANDWIDTH必须包含，十进制整数，单位为比特<br>PROGRAM-ID Master Playlist中通过不同的PROGRAM-ID表示相同presentation的不同编码<br>CODECS引用字符串，value通过逗号分割，建议包含<br>RESOLUTION 视频分辨率<br>AUDIO 引用字符串，和GROUP-ID相同<br>VIDEO 引用字符串，和GROUP-ID相同<br>SUBTITLES 引用字符串，和GROUP-ID相同</p>\n<h2 id=\"EXT-X-DISCONTUNUITY\"><a href=\"#EXT-X-DISCONTUNUITY\" class=\"headerlink\" title=\"EXT-X-DISCONTUNUITY\"></a>EXT-X-DISCONTUNUITY</h2><p>媒体信息发生变化，媒体信息包括文件格式，tracks的数量和类型，编码参数，编码顺序(encoding sequence)，时间戳顺序(timestamp sequence)</p>\n<h2 id=\"EXT-X-I-FRAMES-ONLY\"><a href=\"#EXT-X-I-FRAMES-ONLY\" class=\"headerlink\" title=\"EXT-X-I-FRAMES-ONLY\"></a>EXT-X-I-FRAMES-ONLY</h2><p>表示分片只包含I帧，协议从版本号4开始包含此标签</p>\n<h2 id=\"EXT-X-MAP\"><a href=\"#EXT-X-MAP\" class=\"headerlink\" title=\"EXT-X-MAP:\"></a>EXT-X-MAP:<attribute-list></attribute-list></h2><p>标识如何获取分片的PAT/PMT，对该标签之后的分片有效<br>仅和EXT-X-I-FRAMES-ONLY一起出现，建议只用在没有PAT/PMT开头的分片<br>协议从版本号5开始使用该标签<br>URI引用字符串<br>BYTERANGE引用字符串</p>\n<h2 id=\"EXT-X-I-FRAME-STREAM-INF\"><a href=\"#EXT-X-I-FRAME-STREAM-INF\" class=\"headerlink\" title=\"EXT-X-I-FRAME-STREAM-INF:\"></a>EXT-X-I-FRAME-STREAM-INF:<attribute-list></attribute-list></h2><p>表示I帧列表<br>URI<br>BANDWIDTH</p>\n<h2 id=\"EXT-X-VERSION\"><a href=\"#EXT-X-VERSION\" class=\"headerlink\" title=\"EXT-X-VERSION:\"></a>EXT-X-VERSION:<n></n></h2><p>协议版本号</p>\n<h1 id=\"额外的注意：\"><a href=\"#额外的注意：\" class=\"headerlink\" title=\"额外的注意：\"></a>额外的注意：</h1><ol>\n<li>media segment：分片</li>\n<li>编码 MPEG-2 Transport Stream/MPEG audio elementary stream/WebVTT（字幕）</li>\n<li>TS分片必须仅包含一个MPEG-2 Program。每一个TS分片都应当以PAT和PMT开头。视频分片必须包含一个I帧（完整GOP？）</li>\n<li>TS或者audio elementacontentry stream分片必须保证sequence number连续，时间戳连续，除非是第一个分片或者出现了EXT-X-DISCONTINUITY标签。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Playlist\"><a href=\"#Playlist\" class=\"headerlink\" title=\"Playlist\"></a>Playlist</h1><ul>\n<li>m3u8：扩展的M3U文件，以行分割，每一行结尾是LF或者CR LF。每一行表示一个URI，空行（被忽略）或者以#开头（注释或者tag/标签）。不能包含空格（？）。</li>\n<li>URI：表示一个分片或者一个playlist文件。可能是相对路径，若是，则根据该playlist路径拼凑完整路径。</li>\n<li>Media Playlist：仅包含分片的palylist</li>\n<li>Master Playlist：仅包含playlist的playlist</li>\n<li>Tags：以#EXT开头，所有其他的以#开头的行均是注释。</li>\n<li>duartion：所有分片duration之和</li>\n<li><p>编码：HTTP Content-Type “application/vnd.apple.mpegurl”的m3u8文件为UTF-8编码，HTTP Content-Type “audio/mpegurl”的m3u文件为US-ASCII编码</p>\n</li>\n<li><p>AttributeName=AttributeValue,AttributeName=AttributeValue,…</p>\n<p>  AttributeName不能包含空格，只能由A～Z和”-“组成，同一个AttributeName在一个attribute list中不能重复。<br>  AttributeValue只能是10进制数字，十六进制数字(0x/0X)，十进制浮点数，引号包裹的字符串（“），没有引号包裹的可枚举字符串（？），十进制分辨率(widthxheight)</p>\n</li>\n</ul>\n<h2 id=\"EXTM3U\"><a href=\"#EXTM3U\" class=\"headerlink\" title=\"EXTM3U\"></a>EXTM3U</h2><p>区分M3U8和M8U文件的标签</p>\n<h2 id=\"EXTINF\"><a href=\"#EXTINF\" class=\"headerlink\" title=\"EXTINF\"></a>EXTINF</h2><p>标识分片的duration，格式：</p>\n<pre><code>#EXTINF:&lt;duration&gt;,&lt;value&gt;\n</code></pre><p>duration是十进制数字或者十进制浮点数，单位为秒，协议版本号低于3的仅使用十进制证书<br>value可选</p>\n<h2 id=\"EXT-X-BYTERANGE-o\"><a href=\"#EXT-X-BYTERANGE-o\" class=\"headerlink\" title=\"EXT-X-BYTERANGE:\\[@o]\"></a>EXT-X-BYTERANGE:\\<n>[@o]</n></h2><p>表示sub-range of resource<br>n表示sub-range长度，单位为字节<br>o是一个十进制整数，标识sub-range的起始位置，从resource的开始位置的偏移量，单位为字节<br>协议版本号从4开始使用该标签</p>\n<h2 id=\"EXT-X-TARGETDURATION\"><a href=\"#EXT-X-TARGETDURATION\" class=\"headerlink\" title=\"EXT-X-TARGETDURATION:\\\"></a>EXT-X-TARGETDURATION:\\<s></s></h2><p>表示playlist文件中可能出现的最大duration<br>s是最大duration，以秒为单位</p>\n<h2 id=\"EXT-X-MEDIA-SEQUENCE\"><a href=\"#EXT-X-MEDIA-SEQUENCE\" class=\"headerlink\" title=\"EXT-X-MEDIA-SEQUENCE:\\\"></a>EXT-X-MEDIA-SEQUENCE:\\<number></number></h2><p>标识playlist文件中出现的第一个sequence number，仅出现一次</p>\n<h2 id=\"EXT-X-KEY\"><a href=\"#EXT-X-KEY\" class=\"headerlink\" title=\"EXT-X-KEY:\"></a>EXT-X-KEY:<attribute-list></attribute-list></h2><p>作用域到下一个包含相同KEYFORMAT attribute的EXT-X-KEY标签之前<br>METHOD：NONE, AES-128, SAMPLE-AES，若为NONE，则必须包含URI,VI,KEYFORMAT,KEYFORMATVERSIONS；若为AES-128，则必须包含URI，可选VI；若为SAMPLE-AES，可选VI<br>URI：key的URI<br>IV：Initialization Vector，十六进制整数，协议从版本号2开始包含此变量<br>KEYFORMAT：引用字符串<br>KEYFORMATVERSIONS：引用字符串，出现在协议版本号5中</p>\n<h2 id=\"EXT-X-PROGRAM-DATE-TIME-YYYY-MM-DDThh-mm-ssZ\"><a href=\"#EXT-X-PROGRAM-DATE-TIME-YYYY-MM-DDThh-mm-ssZ\" class=\"headerlink\" title=\"EXT-X-PROGRAM-DATE-TIME:YYYY-MM-DDThh:mm:ssZ\"></a>EXT-X-PROGRAM-DATE-TIME:<a href=\"YYYY-MM-DDThh:mm:ssZ\" target=\"_blank\" rel=\"noopener\">YYYY-MM-DDThh:mm:ssZ</a></h2><p>接下来的第一个的分片时间</p>\n<h2 id=\"EXT-X-ALLOW-CACHE-lt-YES-NO-gt\"><a href=\"#EXT-X-ALLOW-CACHE-lt-YES-NO-gt\" class=\"headerlink\" title=\"EXT-X-ALLOW-CACHE:&lt;YES|NO&gt;\"></a>EXT-X-ALLOW-CACHE:&lt;YES|NO&gt;</h2><p>客户端是否可以缓存分片用于回放，仅能出现一次</p>\n<h2 id=\"EXT-X-PLAYLIST-TYPE-lt-EVENT-VOD-gt\"><a href=\"#EXT-X-PLAYLIST-TYPE-lt-EVENT-VOD-gt\" class=\"headerlink\" title=\"EXT-X-PLAYLIST-TYPE:&lt;EVENT|VOD&gt;\"></a>EXT-X-PLAYLIST-TYPE:&lt;EVENT|VOD&gt;</h2><p>playlist是否可修改</p>\n<h2 id=\"EXT-X-ENDLIST\"><a href=\"#EXT-X-ENDLIST\" class=\"headerlink\" title=\"EXT-X-ENDLIST\"></a>EXT-X-ENDLIST</h2><p>表示不再有分片，仅能出现一次</p>\n<h2 id=\"EXT-X-MEDIA\"><a href=\"#EXT-X-MEDIA\" class=\"headerlink\" title=\"EXT-X-MEDIA:\"></a>EXT-X-MEDIA:<attribute-list></attribute-list></h2><p>用于表示同一内容的不同选择(alternative reditions)，比如只包含音频的英语，法语和西班牙语音轨，或者仅包含视频的两个摄像机机位，format相同<br>URI可选<br>TYPE三选一，VIDEO/AUDIO/SUBTITLES，同一GROUP的必须相同<br>GROUP-ID引用字符串<br>LANGUAGE可选 引用字符串，参考RFC 5646，若AUTOSELECT为YES，则LANGUAGE必须有效<br>NAME引用字符串，同一GROUP的必须不同<br>DEFAULT二选一YES/NO，同一GROUP仅有一个为YES<br>AUTOSELECT二选一YES/NO<br>FORCED二选一YES/NO 可选<br>CHARACTERISTICS引用字符串 可选</p>\n<h2 id=\"EXT-X-STREAM-INF\"><a href=\"#EXT-X-STREAM-INF\" class=\"headerlink\" title=\"EXT-X-STREAM-INF:\\\"></a>EXT-X-STREAM-INF:<attribute-list>\\<uri></uri></attribute-list></h2><p>表示URI为playlist<br>BANDWIDTH必须包含，十进制整数，单位为比特<br>PROGRAM-ID Master Playlist中通过不同的PROGRAM-ID表示相同presentation的不同编码<br>CODECS引用字符串，value通过逗号分割，建议包含<br>RESOLUTION 视频分辨率<br>AUDIO 引用字符串，和GROUP-ID相同<br>VIDEO 引用字符串，和GROUP-ID相同<br>SUBTITLES 引用字符串，和GROUP-ID相同</p>\n<h2 id=\"EXT-X-DISCONTUNUITY\"><a href=\"#EXT-X-DISCONTUNUITY\" class=\"headerlink\" title=\"EXT-X-DISCONTUNUITY\"></a>EXT-X-DISCONTUNUITY</h2><p>媒体信息发生变化，媒体信息包括文件格式，tracks的数量和类型，编码参数，编码顺序(encoding sequence)，时间戳顺序(timestamp sequence)</p>\n<h2 id=\"EXT-X-I-FRAMES-ONLY\"><a href=\"#EXT-X-I-FRAMES-ONLY\" class=\"headerlink\" title=\"EXT-X-I-FRAMES-ONLY\"></a>EXT-X-I-FRAMES-ONLY</h2><p>表示分片只包含I帧，协议从版本号4开始包含此标签</p>\n<h2 id=\"EXT-X-MAP\"><a href=\"#EXT-X-MAP\" class=\"headerlink\" title=\"EXT-X-MAP:\"></a>EXT-X-MAP:<attribute-list></attribute-list></h2><p>标识如何获取分片的PAT/PMT，对该标签之后的分片有效<br>仅和EXT-X-I-FRAMES-ONLY一起出现，建议只用在没有PAT/PMT开头的分片<br>协议从版本号5开始使用该标签<br>URI引用字符串<br>BYTERANGE引用字符串</p>\n<h2 id=\"EXT-X-I-FRAME-STREAM-INF\"><a href=\"#EXT-X-I-FRAME-STREAM-INF\" class=\"headerlink\" title=\"EXT-X-I-FRAME-STREAM-INF:\"></a>EXT-X-I-FRAME-STREAM-INF:<attribute-list></attribute-list></h2><p>表示I帧列表<br>URI<br>BANDWIDTH</p>\n<h2 id=\"EXT-X-VERSION\"><a href=\"#EXT-X-VERSION\" class=\"headerlink\" title=\"EXT-X-VERSION:\"></a>EXT-X-VERSION:<n></n></h2><p>协议版本号</p>\n<h1 id=\"额外的注意：\"><a href=\"#额外的注意：\" class=\"headerlink\" title=\"额外的注意：\"></a>额外的注意：</h1><ol>\n<li>media segment：分片</li>\n<li>编码 MPEG-2 Transport Stream/MPEG audio elementary stream/WebVTT（字幕）</li>\n<li>TS分片必须仅包含一个MPEG-2 Program。每一个TS分片都应当以PAT和PMT开头。视频分片必须包含一个I帧（完整GOP？）</li>\n<li>TS或者audio elementacontentry stream分片必须保证sequence number连续，时间戳连续，除非是第一个分片或者出现了EXT-X-DISCONTINUITY标签。</li>\n</ol>\n"},{"title":"ConEmu saves PowerShell console","date":"2018-03-07T06:11:48.000Z","_content":"cmd.exe里的字体啊什么的很丑，然后……反正用的不多，就这么算了吧。\n\n可是PowerShell console里的字体依然很丑，可以替换的字体也丑。\n幸好有人推荐了ConEmu，简直救星。","source":"_posts/2018-03-07-PowerShell-font.md","raw":"---\ntitle: ConEmu saves PowerShell console\ndate: 2018-03-07 14:11:48\ntags:\n---\ncmd.exe里的字体啊什么的很丑，然后……反正用的不多，就这么算了吧。\n\n可是PowerShell console里的字体依然很丑，可以替换的字体也丑。\n幸好有人推荐了ConEmu，简直救星。","slug":"PowerShell-font","published":1,"updated":"2018-05-18T05:07:49.520Z","_id":"cjegotus4001hi0fo9mkbce7t","comments":1,"layout":"post","photos":[],"link":"","content":"<p>cmd.exe里的字体啊什么的很丑，然后……反正用的不多，就这么算了吧。</p>\n<p>可是PowerShell console里的字体依然很丑，可以替换的字体也丑。<br>幸好有人推荐了ConEmu，简直救星。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>cmd.exe里的字体啊什么的很丑，然后……反正用的不多，就这么算了吧。</p>\n<p>可是PowerShell console里的字体依然很丑，可以替换的字体也丑。<br>幸好有人推荐了ConEmu，简直救星。</p>\n"},{"title":"migrate to hexo","date":"2018-03-07T05:18:09.000Z","_content":"受够了奇奇怪怪的Jekyll，迁移到hexo。\n\nhexo把静态生成的文件放到了public文件夹里，导致无法用一个repo同时用于保存.md文件和发布blog。\n目前的处理方法是额外创建一个branch用于存储.md文件和hexo本身，当前的master分支用于发布blog。\n姑且试试吧。\n\n======\n# 如何创建新文档\n\n1. 在 `/source/_posts/` 创建新的 `.md` 文档，或者运行 `hexo new post`；\n2. 运行 `hexo serve` 查看新的文档；\n3. 运行 `hexo generate` 生成新的 `.html` 文档；\n4. 提交新的 `.md` 文档到GitHub；\n5. 切换到 `master` 分支，拷贝所有 `/public` 目录下的文件到 `/` ，并提交修改到GitHub。\n","source":"_posts/2018-03-07-migrate-to-hexo.md","raw":"---\ntitle: migrate to hexo\ndate: 2018-03-07 13:18:09\ntags:\n---\n受够了奇奇怪怪的Jekyll，迁移到hexo。\n\nhexo把静态生成的文件放到了public文件夹里，导致无法用一个repo同时用于保存.md文件和发布blog。\n目前的处理方法是额外创建一个branch用于存储.md文件和hexo本身，当前的master分支用于发布blog。\n姑且试试吧。\n\n======\n# 如何创建新文档\n\n1. 在 `/source/_posts/` 创建新的 `.md` 文档，或者运行 `hexo new post`；\n2. 运行 `hexo serve` 查看新的文档；\n3. 运行 `hexo generate` 生成新的 `.html` 文档；\n4. 提交新的 `.md` 文档到GitHub；\n5. 切换到 `master` 分支，拷贝所有 `/public` 目录下的文件到 `/` ，并提交修改到GitHub。\n","slug":"migrate-to-hexo","published":1,"updated":"2018-07-20T07:54:41.275Z","_id":"cjegotus8001ji0foyicxh6ut","comments":1,"layout":"post","photos":[],"link":"","content":"<p>受够了奇奇怪怪的Jekyll，迁移到hexo。</p>\n<p>hexo把静态生成的文件放到了public文件夹里，导致无法用一个repo同时用于保存.md文件和发布blog。<br>目前的处理方法是额外创建一个branch用于存储.md文件和hexo本身，当前的master分支用于发布blog。<br>姑且试试吧。</p>\n<p>======</p>\n<h1 id=\"如何创建新文档\"><a href=\"#如何创建新文档\" class=\"headerlink\" title=\"如何创建新文档\"></a>如何创建新文档</h1><ol>\n<li>在 <code>/source/_posts/</code> 创建新的 <code>.md</code> 文档，或者运行 <code>hexo new post</code>；</li>\n<li>运行 <code>hexo serve</code> 查看新的文档；</li>\n<li>运行 <code>hexo generate</code> 生成新的 <code>.html</code> 文档；</li>\n<li>提交新的 <code>.md</code> 文档到GitHub；</li>\n<li>切换到 <code>master</code> 分支，拷贝所有 <code>/public</code> 目录下的文件到 <code>/</code> ，并提交修改到GitHub。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>受够了奇奇怪怪的Jekyll，迁移到hexo。</p>\n<p>hexo把静态生成的文件放到了public文件夹里，导致无法用一个repo同时用于保存.md文件和发布blog。<br>目前的处理方法是额外创建一个branch用于存储.md文件和hexo本身，当前的master分支用于发布blog。<br>姑且试试吧。</p>\n<p>======</p>\n<h1 id=\"如何创建新文档\"><a href=\"#如何创建新文档\" class=\"headerlink\" title=\"如何创建新文档\"></a>如何创建新文档</h1><ol>\n<li>在 <code>/source/_posts/</code> 创建新的 <code>.md</code> 文档，或者运行 <code>hexo new post</code>；</li>\n<li>运行 <code>hexo serve</code> 查看新的文档；</li>\n<li>运行 <code>hexo generate</code> 生成新的 <code>.html</code> 文档；</li>\n<li>提交新的 <code>.md</code> 文档到GitHub；</li>\n<li>切换到 <code>master</code> 分支，拷贝所有 <code>/public</code> 目录下的文件到 <code>/</code> ，并提交修改到GitHub。</li>\n</ol>\n"},{"title":"How to draw a peppa pig using CSS","date":"2018-05-18T05:08:19.000Z","_content":"\n[QcloudCommunity](https://www.v2ex.com/member/QcloudCommunity) succeeded to draw a peppa pig using CSS([here](https://www.v2ex.com/t/455807#)).\n\n<iframe src=\"./peppa.html\" style='width: 800px; height: 800px' scrolling=\"no\"></iframe>","source":"_posts/2018-05-18-how-to-draw-a-peppa-pig-using-CSS.md","raw":"---\ntitle: How to draw a peppa pig using CSS\ndate: 2018-05-18 13:08:19\ntags:\n---\n\n[QcloudCommunity](https://www.v2ex.com/member/QcloudCommunity) succeeded to draw a peppa pig using CSS([here](https://www.v2ex.com/t/455807#)).\n\n<iframe src=\"./peppa.html\" style='width: 800px; height: 800px' scrolling=\"no\"></iframe>","slug":"how-to-draw-a-peppa-pig-using-CSS","published":1,"updated":"2018-07-20T07:51:57.671Z","_id":"cjhbk5zsd000034fo723px3fy","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://www.v2ex.com/member/QcloudCommunity\" target=\"_blank\" rel=\"noopener\">QcloudCommunity</a> succeeded to draw a peppa pig using CSS(<a href=\"https://www.v2ex.com/t/455807#\" target=\"_blank\" rel=\"noopener\">here</a>).</p>\n<iframe src=\"./peppa.html\" style=\"width: 800px; height: 800px\" scrolling=\"no\"></iframe>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.v2ex.com/member/QcloudCommunity\" target=\"_blank\" rel=\"noopener\">QcloudCommunity</a> succeeded to draw a peppa pig using CSS(<a href=\"https://www.v2ex.com/t/455807#\" target=\"_blank\" rel=\"noopener\">here</a>).</p>\n<iframe src=\"./peppa.html\" style=\"width: 800px; height: 800px\" scrolling=\"no\"></iframe>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjegotupw0002i0fori4aivys","tag_id":"cjegotupz0004i0foxnrwikuq","_id":"cjegotuqh000ci0foovyxlg5m"},{"post_id":"cjegotupw0002i0fori4aivys","tag_id":"cjegotuqa0008i0fohwytnn54","_id":"cjegotuqh000di0fodd9ac6kj"},{"post_id":"cjegotuq50005i0foo5vod9gu","tag_id":"cjegotuqg000bi0fo9t3mvr4r","_id":"cjegotuqj000ii0foja9jfhq2"},{"post_id":"cjegotuq50005i0foo5vod9gu","tag_id":"cjegotuqh000ei0fow3um0eqc","_id":"cjegotuqk000ji0fosdcz0sfd"},{"post_id":"cjegotuq50005i0foo5vod9gu","tag_id":"cjegotuqi000fi0foyorosnlp","_id":"cjegotuql000li0fom34kadiz"},{"post_id":"cjegotuq50005i0foo5vod9gu","tag_id":"cjegotuqj000gi0fofl8ihg14","_id":"cjegotuqm000mi0fo5642fu37"},{"post_id":"cjegotuq70006i0foafkljozz","tag_id":"cjegotuqj000hi0fo1vfa174q","_id":"cjegotuqo000oi0for9uonkkr"},{"post_id":"cjegotuq70006i0foafkljozz","tag_id":"cjegotuqk000ki0fog1aae874","_id":"cjegotuqp000pi0fo7m589lt6"},{"post_id":"cjegotuqc0009i0foos5kmdg3","tag_id":"cjegotuqj000hi0fo1vfa174q","_id":"cjegotuqr000si0fodyzqfgsh"},{"post_id":"cjegotuqc0009i0foos5kmdg3","tag_id":"cjegotuqq000qi0fotw1gruhn","_id":"cjegotuqr000ti0foijmqrkab"},{"post_id":"cjegotuqe000ai0fo6han9mb5","tag_id":"cjegotuqq000ri0fofavkf2rj","_id":"cjegotuqr000vi0fo5m5vozcu"},{"post_id":"cjegotuqe000ai0fo6han9mb5","tag_id":"cjegotuqr000ui0foq10pcvu1","_id":"cjegotuqr000wi0fojmjpkwoz"},{"post_id":"cjegoturg000yi0fo5cxlwi4y","tag_id":"cjegotuqq000ri0fofavkf2rj","_id":"cjegoturl0011i0fo9ocp1syg"},{"post_id":"cjegoturd000xi0fo98834wug","tag_id":"cjegoturj000zi0fotwxlrlzq","_id":"cjegoturu0019i0fo0zdpxl08"},{"post_id":"cjegoturd000xi0fo98834wug","tag_id":"cjegoturo0014i0foopmlwexd","_id":"cjegotury001bi0fopc1qvccw"},{"post_id":"cjegoturj0010i0fof3yio202","tag_id":"cjegoturt0017i0fo8c003xb0","_id":"cjegotus0001ei0fop4ii93ik"},{"post_id":"cjegoturn0013i0fo8rez40vg","tag_id":"cjegotury001ci0fo5lvzvapb","_id":"cjegotus7001ii0foy19nllf8"},{"post_id":"cjegoturp0015i0fow6uhw73c","tag_id":"cjegotus3001gi0fo5xj4lbxg","_id":"cjegotusa001li0foypulo5t4"},{"post_id":"cjegoturq0016i0foaemlkyrm","tag_id":"cjegotus9001ki0fo4r5chrnf","_id":"cjegotusb001oi0fo63wk3qaw"},{"post_id":"cjegoturq0016i0foaemlkyrm","tag_id":"cjegotusa001mi0fooeeeqjxd","_id":"cjegotusb001pi0fo5dbqzlsw"},{"post_id":"cjegoturt0018i0foum9lyk80","tag_id":"cjegotusb001ni0fosvpnzcgk","_id":"cjegotusd001ti0foiaczinrh"},{"post_id":"cjegoturt0018i0foum9lyk80","tag_id":"cjegotusc001qi0foddyc3lmb","_id":"cjegotusd001ui0fo32iu6ma1"},{"post_id":"cjegoturt0018i0foum9lyk80","tag_id":"cjegotusc001ri0fot97qid5x","_id":"cjegotusf001vi0fob3ne8448"},{"post_id":"cjegoturz001di0fo0bcplcas","tag_id":"cjegotusd001si0fooxy27nbm","_id":"cjegotusf001wi0fow4nx1nt1"}],"Tag":[{"name":"bottle","_id":"cjegotupz0004i0foxnrwikuq"},{"name":"GAE","_id":"cjegotuqa0008i0fohwytnn54"},{"name":"boost","_id":"cjegotuqg000bi0fo9t3mvr4r"},{"name":"property_tree","_id":"cjegotuqh000ei0fow3um0eqc"},{"name":"read_json","_id":"cjegotuqi000fi0foyorosnlp"},{"name":"threadsafe","_id":"cjegotuqj000gi0fofl8ihg14"},{"name":"nginx","_id":"cjegotuqj000hi0fo1vfa174q"},{"name":"HLS","_id":"cjegotuqk000ki0fog1aae874"},{"name":"rtmp","_id":"cjegotuqq000qi0fotw1gruhn"},{"name":"ffmpeg","_id":"cjegotuqq000ri0fofavkf2rj"},{"name":"librtmp","_id":"cjegotuqr000ui0foq10pcvu1"},{"name":"Nexus","_id":"cjegoturj000zi0fotwxlrlzq"},{"name":"OTG","_id":"cjegoturo0014i0foopmlwexd"},{"name":"wordpress","_id":"cjegoturt0017i0fo8c003xb0"},{"name":"lua","_id":"cjegotury001ci0fo5lvzvapb"},{"name":"resume","_id":"cjegotus3001gi0fo5xj4lbxg"},{"name":"android","_id":"cjegotus9001ki0fo4r5chrnf"},{"name":"eclipse","_id":"cjegotusa001mi0fooeeeqjxd"},{"name":"node","_id":"cjegotusb001ni0fosvpnzcgk"},{"name":"xauth","_id":"cjegotusc001qi0foddyc3lmb"},{"name":"fanfou","_id":"cjegotusc001ri0fot97qid5x"},{"name":"c++","_id":"cjegotusd001si0fooxy27nbm"}]}}